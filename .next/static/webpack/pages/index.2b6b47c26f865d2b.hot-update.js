/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/.prisma/client/index-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/.prisma/client/index-browser.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst {\n  Decimal\n} = __webpack_require__(/*! @prisma/client/runtime/index-browser */ \"./node_modules/@prisma/client/runtime/index-browser.js\")\n\n\nconst Prisma = {}\n\nexports.Prisma = Prisma\n\n/**\n * Prisma Client JS version: 3.9.2\n * Query Engine version: bcc2ff906db47790ee902e7bbc76d7ffb1893009\n */\nPrisma.prismaVersion = {\n  client: \"3.9.2\",\n  engine: \"bcc2ff906db47790ee902e7bbc76d7ffb1893009\"\n}\n\nPrisma.PrismaClientKnownRequestError = () => {\n  throw new Error(`PrismaClientKnownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)};\nPrisma.PrismaClientUnknownRequestError = () => {\n  throw new Error(`PrismaClientUnknownRequestError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientRustPanicError = () => {\n  throw new Error(`PrismaClientRustPanicError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientInitializationError = () => {\n  throw new Error(`PrismaClientInitializationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.PrismaClientValidationError = () => {\n  throw new Error(`PrismaClientValidationError is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.Decimal = Decimal\n\n/**\n * Re-export of sql-template-tag\n */\nPrisma.sql = () => {\n  throw new Error(`sqltag is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.empty = () => {\n  throw new Error(`empty is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.join = () => {\n  throw new Error(`join is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.raw = () => {\n  throw new Error(`raw is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n)}\nPrisma.validator = () => (val) => val\n\n/**\n * Shorthand utilities for JSON filtering\n */\nPrisma.DbNull = 'DbNull'\nPrisma.JsonNull = 'JsonNull'\nPrisma.AnyNull = 'AnyNull'\n\n/**\n * Enums\n */\n// Based on\n// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nfunction makeEnum(x) { return x; }\n\nexports.Prisma.AccountScalarFieldEnum = makeEnum({\n  id: 'id',\n  userId: 'userId',\n  type: 'type',\n  provider: 'provider',\n  providerAccountId: 'providerAccountId',\n  refresh_token: 'refresh_token',\n  access_token: 'access_token',\n  expires_at: 'expires_at',\n  token_type: 'token_type',\n  scope: 'scope',\n  id_token: 'id_token',\n  session_state: 'session_state',\n  oauth_token_secret: 'oauth_token_secret',\n  oauth_token: 'oauth_token'\n});\n\nexports.Prisma.SessionScalarFieldEnum = makeEnum({\n  id: 'id',\n  sessionToken: 'sessionToken',\n  userId: 'userId',\n  expires: 'expires'\n});\n\nexports.Prisma.UserScalarFieldEnum = makeEnum({\n  id: 'id',\n  name: 'name',\n  email: 'email',\n  password: 'password',\n  emailVerified: 'emailVerified',\n  image: 'image'\n});\n\nexports.Prisma.VerificationTokenScalarFieldEnum = makeEnum({\n  identifier: 'identifier',\n  token: 'token',\n  expires: 'expires'\n});\n\nexports.Prisma.MoviesScalarFieldEnum = makeEnum({\n  id: 'id',\n  seen: 'seen',\n  liked: 'liked',\n  disliked: 'disliked',\n  watchlist: 'watchlist',\n  comments: 'comments',\n  adult: 'adult',\n  originalLanguage: 'originalLanguage',\n  originalTitle: 'originalTitle',\n  overview: 'overview',\n  popularity: 'popularity',\n  releaseDate: 'releaseDate',\n  title: 'title',\n  video: 'video',\n  voteAverage: 'voteAverage',\n  voteCount: 'voteCount'\n});\n\nexports.Prisma.BackdropsScalarFieldEnum = makeEnum({\n  id: 'id',\n  w300: 'w300',\n  w780: 'w780',\n  w1280: 'w1280',\n  original: 'original',\n  moviesId: 'moviesId'\n});\n\nexports.Prisma.PostersScalarFieldEnum = makeEnum({\n  id: 'id',\n  w92: 'w92',\n  w154: 'w154',\n  w185: 'w185',\n  w342: 'w342',\n  w500: 'w500',\n  w780: 'w780',\n  original: 'original',\n  moviesId: 'moviesId'\n});\n\nexports.Prisma.GenreScalarFieldEnum = makeEnum({\n  id: 'id',\n  name: 'name',\n  moviesId: 'moviesId'\n});\n\nexports.Prisma.SortOrder = makeEnum({\n  asc: 'asc',\n  desc: 'desc'\n});\n\nexports.Prisma.QueryMode = makeEnum({\n  default: 'default',\n  insensitive: 'insensitive'\n});\n\n\nexports.Prisma.ModelName = makeEnum({\n  Account: 'Account',\n  Session: 'Session',\n  User: 'User',\n  VerificationToken: 'VerificationToken',\n  Movies: 'Movies',\n  Backdrops: 'Backdrops',\n  Posters: 'Posters',\n  Genre: 'Genre'\n});\n\n/**\n * Create the Client\n */\nclass PrismaClient {\n  constructor() {\n    throw new Error(\n      `PrismaClient is unable to be run in the browser.\nIn case this error is unexpected for you, please report it in https://github.com/prisma/prisma/issues`,\n    )\n  }\n}\nexports.PrismaClient = PrismaClient\n\nObject.assign(exports, Prisma)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0dBQXNDOzs7QUFHbEQ7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7OztBQUdELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcz9lYmNjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCB7XG4gIERlY2ltYWxcbn0gPSByZXF1aXJlKCdAcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4LWJyb3dzZXInKVxuXG5cbmNvbnN0IFByaXNtYSA9IHt9XG5cbmV4cG9ydHMuUHJpc21hID0gUHJpc21hXG5cbi8qKlxuICogUHJpc21hIENsaWVudCBKUyB2ZXJzaW9uOiAzLjkuMlxuICogUXVlcnkgRW5naW5lIHZlcnNpb246IGJjYzJmZjkwNmRiNDc3OTBlZTkwMmU3YmJjNzZkN2ZmYjE4OTMwMDlcbiAqL1xuUHJpc21hLnByaXNtYVZlcnNpb24gPSB7XG4gIGNsaWVudDogXCIzLjkuMlwiLFxuICBlbmdpbmU6IFwiYmNjMmZmOTA2ZGI0Nzc5MGVlOTAyZTdiYmM3NmQ3ZmZiMTg5MzAwOVwiXG59XG5cblByaXNtYS5QcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuKX07XG5QcmlzbWEuUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciBpcyB1bmFibGUgdG8gYmUgcnVuIGluIHRoZSBicm93c2VyLlxuSW4gY2FzZSB0aGlzIGVycm9yIGlzIHVuZXhwZWN0ZWQgZm9yIHlvdSwgcGxlYXNlIHJlcG9ydCBpdCBpbiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNgLFxuKX1cblByaXNtYS5QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLkRlY2ltYWwgPSBEZWNpbWFsXG5cbi8qKlxuICogUmUtZXhwb3J0IG9mIHNxbC10ZW1wbGF0ZS10YWdcbiAqL1xuUHJpc21hLnNxbCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBzcWx0YWcgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuZW1wdHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihgZW1wdHkgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEuam9pbiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGBqb2luIGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4pfVxuUHJpc21hLnJhdyA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGByYXcgaXMgdW5hYmxlIHRvIGJlIHJ1biBpbiB0aGUgYnJvd3Nlci5cbkluIGNhc2UgdGhpcyBlcnJvciBpcyB1bmV4cGVjdGVkIGZvciB5b3UsIHBsZWFzZSByZXBvcnQgaXQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS9wcmlzbWEvaXNzdWVzYCxcbil9XG5QcmlzbWEudmFsaWRhdG9yID0gKCkgPT4gKHZhbCkgPT4gdmFsXG5cbi8qKlxuICogU2hvcnRoYW5kIHV0aWxpdGllcyBmb3IgSlNPTiBmaWx0ZXJpbmdcbiAqL1xuUHJpc21hLkRiTnVsbCA9ICdEYk51bGwnXG5QcmlzbWEuSnNvbk51bGwgPSAnSnNvbk51bGwnXG5QcmlzbWEuQW55TnVsbCA9ICdBbnlOdWxsJ1xuXG4vKipcbiAqIEVudW1zXG4gKi9cbi8vIEJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxOTIjaXNzdWVjb21tZW50LTI2MTcyMDI3NVxuZnVuY3Rpb24gbWFrZUVudW0oeCkgeyByZXR1cm4geDsgfVxuXG5leHBvcnRzLlByaXNtYS5BY2NvdW50U2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgdXNlcklkOiAndXNlcklkJyxcbiAgdHlwZTogJ3R5cGUnLFxuICBwcm92aWRlcjogJ3Byb3ZpZGVyJyxcbiAgcHJvdmlkZXJBY2NvdW50SWQ6ICdwcm92aWRlckFjY291bnRJZCcsXG4gIHJlZnJlc2hfdG9rZW46ICdyZWZyZXNoX3Rva2VuJyxcbiAgYWNjZXNzX3Rva2VuOiAnYWNjZXNzX3Rva2VuJyxcbiAgZXhwaXJlc19hdDogJ2V4cGlyZXNfYXQnLFxuICB0b2tlbl90eXBlOiAndG9rZW5fdHlwZScsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBpZF90b2tlbjogJ2lkX3Rva2VuJyxcbiAgc2Vzc2lvbl9zdGF0ZTogJ3Nlc3Npb25fc3RhdGUnLFxuICBvYXV0aF90b2tlbl9zZWNyZXQ6ICdvYXV0aF90b2tlbl9zZWNyZXQnLFxuICBvYXV0aF90b2tlbjogJ29hdXRoX3Rva2VuJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLlNlc3Npb25TY2FsYXJGaWVsZEVudW0gPSBtYWtlRW51bSh7XG4gIGlkOiAnaWQnLFxuICBzZXNzaW9uVG9rZW46ICdzZXNzaW9uVG9rZW4nLFxuICB1c2VySWQ6ICd1c2VySWQnLFxuICBleHBpcmVzOiAnZXhwaXJlcydcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5Vc2VyU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBlbWFpbDogJ2VtYWlsJyxcbiAgcGFzc3dvcmQ6ICdwYXNzd29yZCcsXG4gIGVtYWlsVmVyaWZpZWQ6ICdlbWFpbFZlcmlmaWVkJyxcbiAgaW1hZ2U6ICdpbWFnZSdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5WZXJpZmljYXRpb25Ub2tlblNjYWxhckZpZWxkRW51bSA9IG1ha2VFbnVtKHtcbiAgaWRlbnRpZmllcjogJ2lkZW50aWZpZXInLFxuICB0b2tlbjogJ3Rva2VuJyxcbiAgZXhwaXJlczogJ2V4cGlyZXMnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuTW92aWVzU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgc2VlbjogJ3NlZW4nLFxuICBsaWtlZDogJ2xpa2VkJyxcbiAgZGlzbGlrZWQ6ICdkaXNsaWtlZCcsXG4gIHdhdGNobGlzdDogJ3dhdGNobGlzdCcsXG4gIGNvbW1lbnRzOiAnY29tbWVudHMnLFxuICBhZHVsdDogJ2FkdWx0JyxcbiAgb3JpZ2luYWxMYW5ndWFnZTogJ29yaWdpbmFsTGFuZ3VhZ2UnLFxuICBvcmlnaW5hbFRpdGxlOiAnb3JpZ2luYWxUaXRsZScsXG4gIG92ZXJ2aWV3OiAnb3ZlcnZpZXcnLFxuICBwb3B1bGFyaXR5OiAncG9wdWxhcml0eScsXG4gIHJlbGVhc2VEYXRlOiAncmVsZWFzZURhdGUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdmlkZW86ICd2aWRlbycsXG4gIHZvdGVBdmVyYWdlOiAndm90ZUF2ZXJhZ2UnLFxuICB2b3RlQ291bnQ6ICd2b3RlQ291bnQnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuQmFja2Ryb3BzU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgdzMwMDogJ3czMDAnLFxuICB3NzgwOiAndzc4MCcsXG4gIHcxMjgwOiAndzEyODAnLFxuICBvcmlnaW5hbDogJ29yaWdpbmFsJyxcbiAgbW92aWVzSWQ6ICdtb3ZpZXNJZCdcbn0pO1xuXG5leHBvcnRzLlByaXNtYS5Qb3N0ZXJzU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgdzkyOiAndzkyJyxcbiAgdzE1NDogJ3cxNTQnLFxuICB3MTg1OiAndzE4NScsXG4gIHczNDI6ICd3MzQyJyxcbiAgdzUwMDogJ3c1MDAnLFxuICB3NzgwOiAndzc4MCcsXG4gIG9yaWdpbmFsOiAnb3JpZ2luYWwnLFxuICBtb3ZpZXNJZDogJ21vdmllc0lkJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLkdlbnJlU2NhbGFyRmllbGRFbnVtID0gbWFrZUVudW0oe1xuICBpZDogJ2lkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBtb3ZpZXNJZDogJ21vdmllc0lkJ1xufSk7XG5cbmV4cG9ydHMuUHJpc21hLlNvcnRPcmRlciA9IG1ha2VFbnVtKHtcbiAgYXNjOiAnYXNjJyxcbiAgZGVzYzogJ2Rlc2MnXG59KTtcblxuZXhwb3J0cy5QcmlzbWEuUXVlcnlNb2RlID0gbWFrZUVudW0oe1xuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGluc2Vuc2l0aXZlOiAnaW5zZW5zaXRpdmUnXG59KTtcblxuXG5leHBvcnRzLlByaXNtYS5Nb2RlbE5hbWUgPSBtYWtlRW51bSh7XG4gIEFjY291bnQ6ICdBY2NvdW50JyxcbiAgU2Vzc2lvbjogJ1Nlc3Npb24nLFxuICBVc2VyOiAnVXNlcicsXG4gIFZlcmlmaWNhdGlvblRva2VuOiAnVmVyaWZpY2F0aW9uVG9rZW4nLFxuICBNb3ZpZXM6ICdNb3ZpZXMnLFxuICBCYWNrZHJvcHM6ICdCYWNrZHJvcHMnLFxuICBQb3N0ZXJzOiAnUG9zdGVycycsXG4gIEdlbnJlOiAnR2VucmUnXG59KTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIENsaWVudFxuICovXG5jbGFzcyBQcmlzbWFDbGllbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUHJpc21hQ2xpZW50IGlzIHVuYWJsZSB0byBiZSBydW4gaW4gdGhlIGJyb3dzZXIuXG5JbiBjYXNlIHRoaXMgZXJyb3IgaXMgdW5leHBlY3RlZCBmb3IgeW91LCBwbGVhc2UgcmVwb3J0IGl0IGluIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hL2lzc3Vlc2AsXG4gICAgKVxuICB9XG59XG5leHBvcnRzLlByaXNtYUNsaWVudCA9IFByaXNtYUNsaWVudFxuXG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIFByaXNtYSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.prisma/client/index-browser.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/index-browser.js":
/*!******************************************************!*\
  !*** ./node_modules/@prisma/client/index-browser.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("const prisma = __webpack_require__(/*! .prisma/client/index-browser */ \"./node_modules/.prisma/client/index-browser.js\")\n\nmodule.exports = prisma\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsb0ZBQThCOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvaW5kZXgtYnJvd3Nlci5qcz9jYWZhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByaXNtYSA9IHJlcXVpcmUoJy5wcmlzbWEvY2xpZW50L2luZGV4LWJyb3dzZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByaXNtYVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/index-browser.js\n");

/***/ }),

/***/ "./node_modules/@prisma/client/runtime/index-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/index-browser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// runtime/esm/index-browser.mjs\n__export(exports, {\n  Decimal: () => decimal_default\n});\nvar __defProp2 = Object.defineProperty;\nvar __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, \"name\", { value, configurable: true }), \"__name\");\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  precision: 20,\n  rounding: 4,\n  modulo: 1,\n  toExpNeg: -7,\n  toExpPos: 21,\n  minE: -EXP_LIMIT,\n  maxE: EXP_LIMIT,\n  crypto: false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0)\n    x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s)\n    return new Ctor(NaN);\n  if (min2.gt(max2))\n    throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0])\n    return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys)\n    return xs;\n  if (x.e !== y.e)\n    return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i])\n      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d)\n    return new Ctor(NaN);\n  if (!x.d[0])\n    return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3)\n      n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w)\n      for (; w % 10 == 0; w /= 10)\n        n--;\n    if (n < 0)\n      n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite())\n    return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero())\n    return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(x.s);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero())\n    return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.asin();\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return halfPi.minus(x);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1))\n    return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.e >= 0)\n    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1)\n    return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero())\n    return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s)\n      return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i)\n    x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0)\n      for (i = j; r.d[i] === t.d[i] && i--; )\n        ;\n  }\n  if (k)\n    r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1))\n      return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg.d;\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; )\n        k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (x.d)\n      y.s = -y.s;\n    else\n      y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0])\n      y.s = -y.s;\n    else if (xd[0])\n      y = new Ctor(x);\n    else\n      return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; )\n      d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy)\n      len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i)\n    xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; )\n        xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; )\n    xd.pop();\n  for (; xd[0] === 0; xd.shift())\n    --e;\n  if (!xd[0])\n    return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0])\n    return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s)\n      y = new Ctor(NaN);\n    else if (!x.d)\n      y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0])\n      y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; )\n      d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; )\n    xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)\n    throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k)\n      k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0)\n      n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite())\n    return new Ctor(NaN);\n  if (x.isZero())\n    return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; )\n    r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; )\n    r.pop();\n  if (carry)\n    ++e;\n  else\n    r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0)\n    return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0)\n    rm = Ctor.rounding;\n  else\n    checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd)\n    return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1))\n      throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1)\n      break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d)\n      return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d)\n      return y.s ? x : y;\n    if (!y.d) {\n      if (y.s)\n        y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0])\n    return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1))\n    return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1))\n    return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1)\n      return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0)\n      s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)\n    return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k)\n        str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k)\n      str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; )\n    w /= 10;\n  return str + w;\n}\n__name(digitsToString, \"digitsToString\");\n__name2(digitsToString, \"digitsToString\");\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\n__name(checkInt32, \"checkInt32\");\n__name2(checkInt32, \"checkInt32\");\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10)\n    --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0)\n        rd = rd / 100 | 0;\n      else if (i == 1)\n        rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0)\n        rd = rd / 1e3 | 0;\n      else if (i == 1)\n        rd = rd / 100 | 0;\n      else if (i == 2)\n        rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\n__name(checkRoundingDigits, \"checkRoundingDigits\");\n__name2(checkRoundingDigits, \"checkRoundingDigits\");\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; )\n      arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0)\n          arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\n__name(convertBase, \"convertBase\");\n__name2(convertBase, \"convertBase\");\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero())\n    return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\n__name(cosine, \"cosine\");\n__name2(cosine, \"cosine\");\nvar divide = function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry)\n      x.unshift(carry);\n    return x;\n  }\n  __name(multiplyInteger, \"multiplyInteger\");\n  __name2(multiplyInteger, \"multiplyInteger\");\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  __name(compare, \"compare\");\n  __name2(compare, \"compare\");\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; )\n      a.shift();\n  }\n  __name(subtract, \"subtract\");\n  __name2(subtract, \"subtract\");\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++)\n      ;\n    if (yd[i] > (xd[i] || 0))\n      e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; )\n          rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2)\n          ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL)\n              rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base)\n                k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0)\n                cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL)\n              prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0])\n        qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10)\n        i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out:\n    if (sd != null) {\n      xd = x.d;\n      if (!xd)\n        return x;\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10)\n        digits++;\n      i = sd - digits;\n      if (i < 0) {\n        i += LOG_BASE;\n        j = sd;\n        w = xd[xdi = 0];\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n      } else {\n        xdi = Math.ceil((i + 1) / LOG_BASE);\n        k = xd.length;\n        if (xdi >= k) {\n          if (isTruncated) {\n            for (; k++ <= xdi; )\n              xd.push(0);\n            w = rd = 0;\n            digits = 1;\n            i %= LOG_BASE;\n            j = i - LOG_BASE + 1;\n          } else {\n            break out;\n          }\n        } else {\n          w = k = xd[xdi];\n          for (digits = 1; k >= 10; k /= 10)\n            digits++;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + digits;\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n        }\n      }\n      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n      if (sd < 1 || !xd[0]) {\n        xd.length = 0;\n        if (roundUp) {\n          sd -= x.e + 1;\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n          x.e = -sd || 0;\n        } else {\n          xd[0] = x.e = 0;\n        }\n        return x;\n      }\n      if (i == 0) {\n        xd.length = xdi;\n        k = 1;\n        xdi--;\n      } else {\n        xd.length = xdi + 1;\n        k = mathpow(10, LOG_BASE - i);\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n      }\n      if (roundUp) {\n        for (; ; ) {\n          if (xdi == 0) {\n            for (i = 1, j = xd[0]; j >= 10; j /= 10)\n              i++;\n            j = xd[0] += k;\n            for (k = 1; j >= 10; j /= 10)\n              k++;\n            if (i != k) {\n              x.e++;\n              if (xd[0] == BASE)\n                xd[0] = 1;\n            }\n            break;\n          } else {\n            xd[xdi] += k;\n            if (xd[xdi] != BASE)\n              break;\n            xd[xdi--] = 0;\n            k = 1;\n          }\n        }\n      }\n      for (i = xd.length; xd[--i] === 0; )\n        xd.pop();\n    }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\n__name(finalise, \"finalise\");\n__name2(finalise, \"finalise\");\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite())\n    return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0)\n      str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0)\n      str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len)\n      str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len)\n        str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\n__name(finiteToString, \"finiteToString\");\n__name2(finiteToString, \"finiteToString\");\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10)\n    e++;\n  return e;\n}\n__name(getBase10Exponent, \"getBase10Exponent\");\n__name2(getBase10Exponent, \"getBase10Exponent\");\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr)\n      Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\n__name(getLn10, \"getLn10\");\n__name2(getLn10, \"getLn10\");\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION)\n    throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\n__name(getPi, \"getPi\");\n__name2(getPi, \"getPi\");\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10)\n      len--;\n    for (w = digits[0]; w >= 10; w /= 10)\n      len++;\n  }\n  return len;\n}\n__name(getPrecision, \"getPrecision\");\n__name2(getPrecision, \"getPrecision\");\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; )\n    zs += \"0\";\n  return zs;\n}\n__name(getZeroString, \"getZeroString\");\n__name2(getZeroString, \"getZeroString\");\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k))\n        isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0)\n        ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\n__name(intPow, \"intPow\");\n__name2(intPow, \"intPow\");\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\n__name(isOdd, \"isOdd\");\n__name2(isOdd, \"isOdd\");\nfunction maxOrMin(Ctor, args, ltgt) {\n  var y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    } else if (x[ltgt](y)) {\n      x = y;\n    }\n  }\n  return x;\n}\n__name(maxOrMin, \"maxOrMin\");\n__name2(maxOrMin, \"maxOrMin\");\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum2 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum2.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      j = k;\n      while (j--)\n        sum2 = finalise(sum2.times(sum2), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n  }\n}\n__name(naturalExponential, \"naturalExponential\");\n__name2(naturalExponential, \"naturalExponential\");\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      sum2 = sum2.times(2);\n      if (e !== 0)\n        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum2 = divide(sum2, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n    denominator += 2;\n  }\n}\n__name(naturalLogarithm, \"naturalLogarithm\");\n__name2(naturalLogarithm, \"naturalLogarithm\");\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\n__name(nonFiniteToString, \"nonFiniteToString\");\n__name2(nonFiniteToString, \"nonFiniteToString\");\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1)\n    str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0)\n      e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++)\n    ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)\n    ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0)\n      i += LOG_BASE;\n    if (i < len) {\n      if (i)\n        x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; )\n        x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; )\n      str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\n__name(parseDecimal, \"parseDecimal\");\n__name2(parseDecimal, \"parseDecimal\");\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str))\n      return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str)\n      x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i)\n    xd.pop();\n  if (i < 0)\n    return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat)\n    x = divide(x, divisor, len * 4);\n  if (p)\n    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\n__name(parseOther, \"parseOther\");\n__name2(parseOther, \"parseOther\");\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\n__name(sine, \"sine\");\n__name2(sine, \"sine\");\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; )\n        ;\n      if (j == -1)\n        break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\n__name(taylorSeries, \"taylorSeries\");\n__name2(taylorSeries, \"taylorSeries\");\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e)\n    n *= b;\n  return n;\n}\n__name(tinyPow, \"tinyPow\");\n__name2(tinyPow, \"tinyPow\");\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\n__name(toLessThanHalfPi, \"toLessThanHalfPi\");\n__name2(toLessThanHalfPi, \"toLessThanHalfPi\");\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0)\n      rm = Ctor.rounding;\n    else\n      checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; )\n      xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len)\n        ;\n      for (i = 0, str = \"\"; i < len; i++)\n        str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++)\n              str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len)\n              ;\n            for (i = 1, str = \"1.\"; i < len; i++)\n              str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; )\n          str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len)\n          for (e -= len; e--; )\n            str += \"0\";\n        else if (e < len)\n          str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\n__name(toStringBinary, \"toStringBinary\");\n__name2(toStringBinary, \"toStringBinary\");\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\n__name(truncate, \"truncate\");\n__name2(truncate, \"truncate\");\nfunction abs(x) {\n  return new this(x).abs();\n}\n__name(abs, \"abs\");\n__name2(abs, \"abs\");\nfunction acos(x) {\n  return new this(x).acos();\n}\n__name(acos, \"acos\");\n__name2(acos, \"acos\");\nfunction acosh(x) {\n  return new this(x).acosh();\n}\n__name(acosh, \"acosh\");\n__name2(acosh, \"acosh\");\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\n__name(add, \"add\");\n__name2(add, \"add\");\nfunction asin(x) {\n  return new this(x).asin();\n}\n__name(asin, \"asin\");\n__name2(asin, \"asin\");\nfunction asinh(x) {\n  return new this(x).asinh();\n}\n__name(asinh, \"asinh\");\n__name2(asinh, \"asinh\");\nfunction atan(x) {\n  return new this(x).atan();\n}\n__name(atan, \"atan\");\n__name2(atan, \"atan\");\nfunction atanh(x) {\n  return new this(x).atanh();\n}\n__name(atanh, \"atanh\");\n__name2(atanh, \"atanh\");\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\n__name(atan2, \"atan2\");\n__name2(atan2, \"atan2\");\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\n__name(cbrt, \"cbrt\");\n__name2(cbrt, \"cbrt\");\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\n__name(ceil, \"ceil\");\n__name2(ceil, \"ceil\");\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\n__name(clamp, \"clamp\");\n__name2(clamp, \"clamp\");\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\")\n    throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults)\n      this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])\n        this[p] = v;\n      else\n        throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults)\n    this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\n__name(config, \"config\");\n__name2(config, \"config\");\nfunction cos(x) {\n  return new this(x).cos();\n}\n__name(cos, \"cos\");\n__name2(cos, \"cos\");\nfunction cosh(x) {\n  return new this(x).cosh();\n}\n__name(cosh, \"cosh\");\n__name2(cosh, \"cosh\");\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2))\n      return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)\n          e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      } else if (v * 0 !== 0) {\n        if (!v)\n          x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    } else if (t !== \"string\") {\n      throw Error(invalidArgument + v);\n    }\n    if ((i2 = v.charCodeAt(0)) === 45) {\n      v = v.slice(1);\n      x.s = -1;\n    } else {\n      if (i2 === 43)\n        v = v.slice(1);\n      x.s = 1;\n    }\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n  }\n  __name(Decimal2, \"Decimal2\");\n  __name2(Decimal2, \"Decimal\");\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0)\n    obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; )\n        if (!obj.hasOwnProperty(p = ps[i++]))\n          obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\n__name(clone, \"clone\");\n__name2(clone, \"clone\");\nfunction div(x, y) {\n  return new this(x).div(y);\n}\n__name(div, \"div\");\n__name2(div, \"div\");\nfunction exp(x) {\n  return new this(x).exp();\n}\n__name(exp, \"exp\");\n__name2(exp, \"exp\");\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\n__name(floor, \"floor\");\n__name2(floor, \"floor\");\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\n__name(hypot, \"hypot\");\n__name2(hypot, \"hypot\");\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n__name(isDecimalInstance, \"isDecimalInstance\");\n__name2(isDecimalInstance, \"isDecimalInstance\");\nfunction ln(x) {\n  return new this(x).ln();\n}\n__name(ln, \"ln\");\n__name2(ln, \"ln\");\nfunction log(x, y) {\n  return new this(x).log(y);\n}\n__name(log, \"log\");\n__name2(log, \"log\");\nfunction log2(x) {\n  return new this(x).log(2);\n}\n__name(log2, \"log2\");\n__name2(log2, \"log2\");\nfunction log10(x) {\n  return new this(x).log(10);\n}\n__name(log10, \"log10\");\n__name2(log10, \"log10\");\nfunction max() {\n  return maxOrMin(this, arguments, \"lt\");\n}\n__name(max, \"max\");\n__name2(max, \"max\");\nfunction min() {\n  return maxOrMin(this, arguments, \"gt\");\n}\n__name(min, \"min\");\n__name2(min, \"min\");\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\n__name(mod, \"mod\");\n__name2(mod, \"mod\");\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\n__name(mul, \"mul\");\n__name2(mul, \"mul\");\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\n__name(pow, \"pow\");\n__name2(pow, \"pow\");\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0)\n    sd = this.precision;\n  else\n    checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; )\n      rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--)\n    rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE)\n      rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10)\n      k++;\n    if (k < LOG_BASE)\n      e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\n__name(random, \"random\");\n__name2(random, \"random\");\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n__name(round, \"round\");\n__name2(round, \"round\");\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n__name(sign, \"sign\");\n__name2(sign, \"sign\");\nfunction sin(x) {\n  return new this(x).sin();\n}\n__name(sin, \"sin\");\n__name2(sin, \"sin\");\nfunction sinh(x) {\n  return new this(x).sinh();\n}\n__name(sinh, \"sinh\");\n__name2(sinh, \"sinh\");\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\n__name(sqrt, \"sqrt\");\n__name2(sqrt, \"sqrt\");\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\n__name(sub, \"sub\");\n__name2(sub, \"sub\");\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; )\n    x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\n__name(sum, \"sum\");\n__name2(sum, \"sum\");\nfunction tan(x) {\n  return new this(x).tan();\n}\n__name(tan, \"tan\");\n__name2(tan, \"tan\");\nfunction tanh(x) {\n  return new this(x).tanh();\n}\n__name(tanh, \"tanh\");\n__name2(tanh, \"tanh\");\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\n__name(trunc, \"trunc\");\n__name2(trunc, \"trunc\");\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\nvar decimal_default = Decimal;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQvcnVudGltZS9pbmRleC1icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEYsNERBQTRELDJCQUEyQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFGQUFxRiwyQkFBMkI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9ydW50aW1lL2luZGV4LWJyb3dzZXIuanM/MzQ3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHJ1bnRpbWUvZXNtL2luZGV4LWJyb3dzZXIubWpzXG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIERlY2ltYWw6ICgpID0+IGRlY2ltYWxfZGVmYXVsdFxufSk7XG52YXIgX19kZWZQcm9wMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wMih0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSksIFwiX19uYW1lXCIpO1xudmFyIEVYUF9MSU1JVCA9IDllMTU7XG52YXIgTUFYX0RJR0lUUyA9IDFlOTtcbnZhciBOVU1FUkFMUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xudmFyIExOMTAgPSBcIjIuMzAyNTg1MDkyOTk0MDQ1Njg0MDE3OTkxNDU0Njg0MzY0MjA3NjAxMTAxNDg4NjI4NzcyOTc2MDMzMzI3OTAwOTY3NTcyNjA5Njc3MzUyNDgwMjM1OTk3MjA1MDg5NTk4Mjk4MzQxOTY3Nzg0MDQyMjg2MjQ4NjMzNDA5NTI1NDY1MDgyODA2NzU2NjY2Mjg3MzY5MDk4NzgxNjg5NDgyOTA3MjA4MzI1NTU0NjgwODQzNzk5ODk0ODI2MjMzMTk4NTI4MzkzNTA1MzA4OTY1Mzc3NzMyNjI4ODQ2MTYzMzY2MjIyMjg3Njk4MjE5ODg2NzQ2NTQzNjY3NDc0NDA0MjQzMjc0MzY1MTU1MDQ4OTM0MzE0OTM5MzkxNDc5NjE5NDA0NDAwMjIyMTA1MTAxNzE0MTc0ODAwMzY4ODA4NDAxMjY0NzA4MDY4NTU2Nzc0MzIxNjIyODM1NTIyMDExNDgwNDY2MzcxNTY1OTEyMTM3MzQ1MDc0Nzg1Njk0NzY4MzQ2MzYxNjc5MjEwMTgwNjQ0NTA3MDY0ODAwMDI3NzUwMjY4NDkxNjc0NjU1MDU4Njg1NjkzNTY3MzQyMDY3MDU4MTEzNjQyOTIyNDU1NDQwNTc1ODkyNTcyNDIwODI0MTMxNDY5NTY4OTAxNjc1ODk0MDI1Njc3NjMxMTM1NjkxOTI5MjAzMzM3NjU4NzE0MTY2MDIzMDEwNTcwMzA4OTYzNDU3MjA3NTQ0MDM3MDg0NzQ2OTk0MDE2ODI2OTI4MjgwODQ4MTE4NDI4OTMxNDg0ODUyNDk0ODY0NDg3MTkyNzgwOTY3NjI3MTI3NTc3NTM5NzAyNzY2ODYwNTk1MjQ5NjcxNjY3NDE4MzQ4NTcwNDQyMjUwNzE5Nzk2NTAwNDcxNDk1MTA1MDQ5MjIxNDc3NjU2NzYzNjkzODY2Mjk3Njk3OTUyMjExMDcxODI2NDU0OTczNDc3MjY2MjQyNTcwOTQyOTMyMjU4Mjc5ODUwMjU4NTUwOTc4NTI2NTM4MzIwNzYwNjcyNjMxNzE2NDMwOTUwNTk5NTA4NzgwNzUyMzcxMDMzMzEwMTE5Nzg1NzU0NzMzMTU0MTQyMTgwODQyNzU0Mzg2MzU5MTc3ODExNzA1NDMwOTgyNzQ4MjM4NTA0NTY0ODAxOTA5NTYxMDI5OTI5MTgyNDMxODIzNzUyNTM1NzcwOTc1MDUzOTU2NTE4NzY5NzUxMDM3NDk3MDg4ODY5MjE4MDIwNTE4OTMzOTUwNzIzODUzOTIwNTE0NDYzNDE5NzI2NTI4NzI4Njk2NTExMDg2MjU3MTQ5MjE5ODg0OTk3ODc0ODg3Mzc3MTM0NTY4NjIwOTE2NzA1OFwiO1xudmFyIFBJID0gXCIzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODlcIjtcbnZhciBERUZBVUxUUyA9IHtcbiAgcHJlY2lzaW9uOiAyMCxcbiAgcm91bmRpbmc6IDQsXG4gIG1vZHVsbzogMSxcbiAgdG9FeHBOZWc6IC03LFxuICB0b0V4cFBvczogMjEsXG4gIG1pbkU6IC1FWFBfTElNSVQsXG4gIG1heEU6IEVYUF9MSU1JVCxcbiAgY3J5cHRvOiBmYWxzZVxufTtcbnZhciBpbmV4YWN0O1xudmFyIHF1YWRyYW50O1xudmFyIGV4dGVybmFsID0gdHJ1ZTtcbnZhciBkZWNpbWFsRXJyb3IgPSBcIltEZWNpbWFsRXJyb3JdIFwiO1xudmFyIGludmFsaWRBcmd1bWVudCA9IGRlY2ltYWxFcnJvciArIFwiSW52YWxpZCBhcmd1bWVudDogXCI7XG52YXIgcHJlY2lzaW9uTGltaXRFeGNlZWRlZCA9IGRlY2ltYWxFcnJvciArIFwiUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkXCI7XG52YXIgY3J5cHRvVW5hdmFpbGFibGUgPSBkZWNpbWFsRXJyb3IgKyBcImNyeXB0byB1bmF2YWlsYWJsZVwiO1xudmFyIHRhZyA9IFwiW29iamVjdCBEZWNpbWFsXVwiO1xudmFyIG1hdGhmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbWF0aHBvdyA9IE1hdGgucG93O1xudmFyIGlzQmluYXJ5ID0gL14wYihbMDFdKyhcXC5bMDFdKik/fFxcLlswMV0rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaTtcbnZhciBpc09jdGFsID0gL14wbyhbMC03XSsoXFwuWzAtN10qKT98XFwuWzAtN10rKShwWystXT9cXGQrKT8kL2k7XG52YXIgaXNEZWNpbWFsID0gL14oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pO1xudmFyIEJBU0UgPSAxZTc7XG52YXIgTE9HX0JBU0UgPSA3O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIExOMTBfUFJFQ0lTSU9OID0gTE4xMC5sZW5ndGggLSAxO1xudmFyIFBJX1BSRUNJU0lPTiA9IFBJLmxlbmd0aCAtIDE7XG52YXIgUCA9IHsgdG9TdHJpbmdUYWc6IHRhZyB9O1xuUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgaWYgKHgucyA8IDApXG4gICAgeC5zID0gMTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xufTtcblAuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xufTtcblAuY2xhbXBlZFRvID0gUC5jbGFtcCA9IGZ1bmN0aW9uKG1pbjIsIG1heDIpIHtcbiAgdmFyIGssIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgbWluMiA9IG5ldyBDdG9yKG1pbjIpO1xuICBtYXgyID0gbmV3IEN0b3IobWF4Mik7XG4gIGlmICghbWluMi5zIHx8ICFtYXgyLnMpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmIChtaW4yLmd0KG1heDIpKVxuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG1heDIpO1xuICBrID0geC5jbXAobWluMik7XG4gIHJldHVybiBrIDwgMCA/IG1pbjIgOiB4LmNtcChtYXgyKSA+IDAgPyBtYXgyIDogbmV3IEN0b3IoeCk7XG59O1xuUC5jb21wYXJlZFRvID0gUC5jbXAgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBpLCBqLCB4ZEwsIHlkTCwgeCA9IHRoaXMsIHhkID0geC5kLCB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsIHhzID0geC5zLCB5cyA9IHkucztcbiAgaWYgKCF4ZCB8fCAheWQpIHtcbiAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgfVxuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSlcbiAgICByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcbiAgaWYgKHhzICE9PSB5cylcbiAgICByZXR1cm4geHM7XG4gIGlmICh4LmUgIT09IHkuZSlcbiAgICByZXR1cm4geC5lID4geS5lIF4geHMgPCAwID8gMSA6IC0xO1xuICB4ZEwgPSB4ZC5sZW5ndGg7XG4gIHlkTCA9IHlkLmxlbmd0aDtcbiAgZm9yIChpID0gMCwgaiA9IHhkTCA8IHlkTCA/IHhkTCA6IHlkTDsgaSA8IGo7ICsraSkge1xuICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pXG4gICAgICByZXR1cm4geGRbaV0gPiB5ZFtpXSBeIHhzIDwgMCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4geGRMID09PSB5ZEwgPyAwIDogeGRMID4geWRMIF4geHMgPCAwID8gMSA6IC0xO1xufTtcblAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguZClcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKCF4LmRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gMyA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAuY3ViZVJvb3QgPSBQLmNicnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzID0geC5zICogbWF0aHBvdyh4LnMgKiB4LCAxIC8gMyk7XG4gIGlmICghcyB8fCBNYXRoLmFicyhzKSA9PSAxIC8gMCkge1xuICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xuICAgIGUgPSB4LmU7XG4gICAgaWYgKHMgPSAoZSAtIG4ubGVuZ3RoICsgMSkgJSAzKVxuICAgICAgbiArPSBzID09IDEgfHwgcyA9PSAtMiA/IFwiMFwiIDogXCIwMFwiO1xuICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgICByLnMgPSB4LnM7XG4gIH0gZWxzZSB7XG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSByO1xuICAgIHQzID0gdC50aW1lcyh0KS50aW1lcyh0KTtcbiAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcbiAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHcsIGQgPSB0aGlzLmQsIG4gPSBOYU47XG4gIGlmIChkKSB7XG4gICAgdyA9IGQubGVuZ3RoIC0gMTtcbiAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xuICAgIHcgPSBkW3ddO1xuICAgIGlmICh3KVxuICAgICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKVxuICAgICAgICBuLS07XG4gICAgaWYgKG4gPCAwKVxuICAgICAgbiA9IDA7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIGRpdmlkZSh0aGlzLCBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih5KSk7XG59O1xuUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmRpdlRvSW50ID0gZnVuY3Rpb24oeSkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZmluYWxpc2UoZGl2aWRlKHgsIG5ldyBDdG9yKHkpLCAwLCAxLCAxKSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xufTtcblAuZXF1YWxzID0gUC5lcSA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID09PSAwO1xufTtcblAuZmxvb3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcbn07XG5QLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcbn07XG5QLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBrID0gdGhpcy5jbXAoeSk7XG4gIHJldHVybiBrID09IDEgfHwgayA9PT0gMDtcbn07XG5QLmh5cGVyYm9saWNDb3NpbmUgPSBQLmNvc2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIG4sIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIG9uZSA9IG5ldyBDdG9yKDEpO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5zID8gMSAvIDAgOiBOYU4pO1xuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gb25lO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMyKSB7XG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcbiAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxNjtcbiAgICBuID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gIH1cbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKG4pLCBuZXcgQ3RvcigxKSwgdHJ1ZSk7XG4gIHZhciBjb3NoMl94LCBpID0gaywgZDggPSBuZXcgQ3Rvcig4KTtcbiAgZm9yICg7IGktLTsgKSB7XG4gICAgY29zaDJfeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZSh4LCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMpIHtcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgICB2YXIgc2luaDJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gICAgZm9yICg7IGstLTsgKSB7XG4gICAgICBzaW5oMl94ID0geC50aW1lcyh4KTtcbiAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luaDJfeC50aW1lcyhkMTYudGltZXMoc2luaDJfeCkucGx1cyhkMjApKSkpO1xuICAgIH1cbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5zKTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA3O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgcmV0dXJuIGRpdmlkZSh4LnNpbmgoKSwgeC5jb3NoKCksIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSk7XG59O1xuUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYWxmUGksIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgayA9IHguYWJzKCkuY21wKDEpLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIHJldHVybiBrID09PSAwID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApIDogbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBpZiAoeC5pc1plcm8oKSlcbiAgICByZXR1cm4gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5hc2luKCk7XG4gIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGhhbGZQaS5taW51cyh4KTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljQ29zaW5lID0gUC5hY29zaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICh4Lmx0ZSgxKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5lcSgxKSA/IDAgOiBOYU4pO1xuICBpZiAoIXguaXNGaW5pdGUoKSlcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC5sbigpO1xufTtcblAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAyICogTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDY7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICB4ID0geC50aW1lcyh4KS5wbHVzKDEpLnNxcnQoKS5wbHVzKHgpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgubG4oKTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljVGFuZ2VudCA9IFAuYXRhbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgd3ByLCB4c2QsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmUgPj0gMClcbiAgICByZXR1cm4gbmV3IEN0b3IoeC5hYnMoKS5lcSgxKSA/IHgucyAvIDAgOiB4LmlzWmVybygpID8geCA6IE5hTik7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgeHNkID0geC5zZCgpO1xuICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xuICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHhzZCAtIHguZTtcbiAgeCA9IGRpdmlkZSh4LnBsdXMoMSksIG5ldyBDdG9yKDEpLm1pbnVzKHgpLCB3cHIgKyBwciwgMSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHgubG4oKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC50aW1lcygwLjUpO1xufTtcblAuaW52ZXJzZVNpbmUgPSBQLmFzaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhbGZQaSwgaywgcHIsIHJtLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgayA9IHguYWJzKCkuY21wKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgaGFsZlBpLnMgPSB4LnM7XG4gICAgICByZXR1cm4gaGFsZlBpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmRpdihuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LnRpbWVzKDIpO1xufTtcblAuaW52ZXJzZVRhbmdlbnQgPSBQLmF0YW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGksIGosIGssIG4sIHB4LCB0LCByLCB3cHIsIHgyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICBpZiAoIXgucylcbiAgICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgIGlmIChwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XG4gICAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcbiAgICAgIHIucyA9IHgucztcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4LmlzWmVybygpKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICB9IGVsc2UgaWYgKHguYWJzKCkuZXEoMSkgJiYgcHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xuICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjI1KTtcbiAgICByLnMgPSB4LnM7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSBwciArIDEwO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcbiAgZm9yIChpID0gazsgaTsgLS1pKVxuICAgIHggPSB4LmRpdih4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoMSkpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBqID0gTWF0aC5jZWlsKHdwciAvIExPR19CQVNFKTtcbiAgbiA9IDE7XG4gIHgyID0geC50aW1lcyh4KTtcbiAgciA9IG5ldyBDdG9yKHgpO1xuICBweCA9IHg7XG4gIGZvciAoOyBpICE9PSAtMTsgKSB7XG4gICAgcHggPSBweC50aW1lcyh4Mik7XG4gICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xuICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgIHIgPSB0LnBsdXMocHguZGl2KG4gKz0gMikpO1xuICAgIGlmIChyLmRbal0gIT09IHZvaWQgMClcbiAgICAgIGZvciAoaSA9IGo7IHIuZFtpXSA9PT0gdC5kW2ldICYmIGktLTsgKVxuICAgICAgICA7XG4gIH1cbiAgaWYgKGspXG4gICAgciA9IHIudGltZXMoMiA8PCBrIC0gMSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG59O1xuUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQ7XG59O1xuUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XG59O1xuUC5pc05hTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucztcbn07XG5QLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPCAwO1xufTtcblAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucyA+IDA7XG59O1xuUC5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcbn07XG5QLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcbn07XG5QLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XG59O1xuUC5sb2dhcml0aG0gPSBQLmxvZyA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLCBhcmcgPSB0aGlzLCBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmcsIGd1YXJkID0gNTtcbiAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XG4gICAgaXNCYXNlMTAgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcbiAgICBkID0gYmFzZS5kO1xuICAgIGlmIChiYXNlLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGJhc2UuZXEoMSkpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpc0Jhc2UxMCA9IGJhc2UuZXEoMTApO1xuICB9XG4gIGQgPSBhcmcuZDtcbiAgaWYgKGFyZy5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBhcmcuZXEoMSkpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoZCAmJiAhZFswXSA/IC0xIC8gMCA6IGFyZy5zICE9IDEgPyBOYU4gOiBkID8gMCA6IDEgLyAwKTtcbiAgfVxuICBpZiAoaXNCYXNlMTApIHtcbiAgICBpZiAoZC5sZW5ndGggPiAxKSB7XG4gICAgICBpbmYgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGsgPSBkWzBdOyBrICUgMTAgPT09IDA7IClcbiAgICAgICAgayAvPSAxMDtcbiAgICAgIGluZiA9IGsgIT09IDE7XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHNkID0gcHIgKyBndWFyZDtcbiAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcbiAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcbiAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XG4gIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayA9IHByLCBybSkpIHtcbiAgICBkbyB7XG4gICAgICBzZCArPSAxMDtcbiAgICAgIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XG4gICAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xuICAgICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XG4gICAgICBpZiAoIWluZikge1xuICAgICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UoayArIDEsIGsgKyAxNSkgKyAxID09IDFlMTQpIHtcbiAgICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayArPSAxMCwgcm0pKTtcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xufTtcblAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGQsIGUsIGksIGosIGssIGxlbiwgcHIsIHJtLCB4ZCwgeGUsIHhMVHksIHlkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xuICAgIGlmICgheC5zIHx8ICF5LnMpXG4gICAgICB5ID0gbmV3IEN0b3IoTmFOKTtcbiAgICBlbHNlIGlmICh4LmQpXG4gICAgICB5LnMgPSAteS5zO1xuICAgIGVsc2VcbiAgICAgIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zICE9PSB5LnMgPyB4IDogTmFOKTtcbiAgICByZXR1cm4geTtcbiAgfVxuICBpZiAoeC5zICE9IHkucykge1xuICAgIHkucyA9IC15LnM7XG4gICAgcmV0dXJuIHgucGx1cyh5KTtcbiAgfVxuICB4ZCA9IHguZDtcbiAgeWQgPSB5LmQ7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcbiAgICBpZiAoeWRbMF0pXG4gICAgICB5LnMgPSAteS5zO1xuICAgIGVsc2UgaWYgKHhkWzBdKVxuICAgICAgeSA9IG5ldyBDdG9yKHgpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG4gIH1cbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcbiAgeGQgPSB4ZC5zbGljZSgpO1xuICBrID0geGUgLSBlO1xuICBpZiAoaykge1xuICAgIHhMVHkgPSBrIDwgMDtcbiAgICBpZiAoeExUeSkge1xuICAgICAgZCA9IHhkO1xuICAgICAgayA9IC1rO1xuICAgICAgbGVuID0geWQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0geWQ7XG4gICAgICBlID0geGU7XG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgfVxuICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xuICAgIGlmIChrID4gaSkge1xuICAgICAgayA9IGk7XG4gICAgICBkLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGQucmV2ZXJzZSgpO1xuICAgIGZvciAoaSA9IGs7IGktLTsgKVxuICAgICAgZC5wdXNoKDApO1xuICAgIGQucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIGkgPSB4ZC5sZW5ndGg7XG4gICAgbGVuID0geWQubGVuZ3RoO1xuICAgIHhMVHkgPSBpIDwgbGVuO1xuICAgIGlmICh4TFR5KVxuICAgICAgbGVuID0gaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xuICAgICAgICB4TFR5ID0geGRbaV0gPCB5ZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGsgPSAwO1xuICB9XG4gIGlmICh4TFR5KSB7XG4gICAgZCA9IHhkO1xuICAgIHhkID0geWQ7XG4gICAgeWQgPSBkO1xuICAgIHkucyA9IC15LnM7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpXG4gICAgeGRbbGVuKytdID0gMDtcbiAgZm9yIChpID0geWQubGVuZ3RoOyBpID4gazsgKSB7XG4gICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xuICAgICAgZm9yIChqID0gaTsgaiAmJiB4ZFstLWpdID09PSAwOyApXG4gICAgICAgIHhkW2pdID0gQkFTRSAtIDE7XG4gICAgICAtLXhkW2pdO1xuICAgICAgeGRbaV0gKz0gQkFTRTtcbiAgICB9XG4gICAgeGRbaV0gLT0geWRbaV07XG4gIH1cbiAgZm9yICg7IHhkWy0tbGVuXSA9PT0gMDsgKVxuICAgIHhkLnBvcCgpO1xuICBmb3IgKDsgeGRbMF0gPT09IDA7IHhkLnNoaWZ0KCkpXG4gICAgLS1lO1xuICBpZiAoIXhkWzBdKVxuICAgIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XG4gIHkuZCA9IHhkO1xuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xufTtcblAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBxLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSlcbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xuICAgIHEgPSBkaXZpZGUoeCwgeS5hYnMoKSwgMCwgMywgMSk7XG4gICAgcS5zICo9IHkucztcbiAgfSBlbHNlIHtcbiAgICBxID0gZGl2aWRlKHgsIHksIDAsIEN0b3IubW9kdWxvLCAxKTtcbiAgfVxuICBxID0gcS50aW1lcyh5KTtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4geC5taW51cyhxKTtcbn07XG5QLm5hdHVyYWxFeHBvbmVudGlhbCA9IFAuZXhwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XG59O1xuUC5uYXR1cmFsTG9nYXJpdGhtID0gUC5sbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmF0dXJhbExvZ2FyaXRobSh0aGlzKTtcbn07XG5QLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICB4LnMgPSAteC5zO1xuICByZXR1cm4gZmluYWxpc2UoeCk7XG59O1xuUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBjYXJyeSwgZCwgZSwgaSwgaywgbGVuLCBwciwgcm0sIHhkLCB5ZCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LmQpIHtcbiAgICBpZiAoIXgucyB8fCAheS5zKVxuICAgICAgeSA9IG5ldyBDdG9yKE5hTik7XG4gICAgZWxzZSBpZiAoIXguZClcbiAgICAgIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zID09PSB5LnMgPyB4IDogTmFOKTtcbiAgICByZXR1cm4geTtcbiAgfVxuICBpZiAoeC5zICE9IHkucykge1xuICAgIHkucyA9IC15LnM7XG4gICAgcmV0dXJuIHgubWludXMoeSk7XG4gIH1cbiAgeGQgPSB4LmQ7XG4gIHlkID0geS5kO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgaWYgKCF5ZFswXSlcbiAgICAgIHkgPSBuZXcgQ3Rvcih4KTtcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgfVxuICBrID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIHhkID0geGQuc2xpY2UoKTtcbiAgaSA9IGsgLSBlO1xuICBpZiAoaSkge1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgZCA9IHhkO1xuICAgICAgaSA9IC1pO1xuICAgICAgbGVuID0geWQubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0geWQ7XG4gICAgICBlID0gaztcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcbiAgICB9XG4gICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcbiAgICBsZW4gPSBrID4gbGVuID8gayArIDEgOiBsZW4gKyAxO1xuICAgIGlmIChpID4gbGVuKSB7XG4gICAgICBpID0gbGVuO1xuICAgICAgZC5sZW5ndGggPSAxO1xuICAgIH1cbiAgICBkLnJldmVyc2UoKTtcbiAgICBmb3IgKDsgaS0tOyApXG4gICAgICBkLnB1c2goMCk7XG4gICAgZC5yZXZlcnNlKCk7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBpID0geWQubGVuZ3RoO1xuICBpZiAobGVuIC0gaSA8IDApIHtcbiAgICBpID0gbGVuO1xuICAgIGQgPSB5ZDtcbiAgICB5ZCA9IHhkO1xuICAgIHhkID0gZDtcbiAgfVxuICBmb3IgKGNhcnJ5ID0gMDsgaTsgKSB7XG4gICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcbiAgICB4ZFtpXSAlPSBCQVNFO1xuICB9XG4gIGlmIChjYXJyeSkge1xuICAgIHhkLnVuc2hpZnQoY2FycnkpO1xuICAgICsrZTtcbiAgfVxuICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7IClcbiAgICB4ZC5wb3AoKTtcbiAgeS5kID0geGQ7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XG59O1xuUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24oeikge1xuICB2YXIgaywgeCA9IHRoaXM7XG4gIGlmICh6ICE9PSB2b2lkIDAgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMClcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcbiAgaWYgKHguZCkge1xuICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcbiAgICBpZiAoeiAmJiB4LmUgKyAxID4gaylcbiAgICAgIGsgPSB4LmUgKyAxO1xuICB9IGVsc2Uge1xuICAgIGsgPSBOYU47XG4gIH1cbiAgcmV0dXJuIGs7XG59O1xuUC5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHguZSArIDEsIEN0b3Iucm91bmRpbmcpO1xufTtcblAuc2luZSA9IFAuc2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0gc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XG59O1xuUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LCB4ID0gdGhpcywgZCA9IHguZCwgZSA9IHguZSwgcyA9IHgucywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzICE9PSAxIHx8ICFkIHx8ICFkWzBdKSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHMgPSBNYXRoLnNxcnQoK3gpO1xuICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoZCk7XG4gICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKVxuICAgICAgbiArPSBcIjBcIjtcbiAgICBzID0gTWF0aC5zcXJ0KG4pO1xuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgfSBlbHNlIHtcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgfVxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IHI7XG4gICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMTA7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5zaW4oKTtcbiAgeC5zID0gMTtcbiAgeCA9IGRpdmlkZSh4LCBuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCksIHByICsgMTAsIDApO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA9PSAyIHx8IHF1YWRyYW50ID09IDQgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLnRpbWVzID0gUC5tdWwgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBjYXJyeSwgZSwgaSwgaywgciwgckwsIHQsIHhkTCwgeWRMLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHhkID0geC5kLCB5ZCA9ICh5ID0gbmV3IEN0b3IoeSkpLmQ7XG4gIHkucyAqPSB4LnM7XG4gIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGQgPyBOYU4gOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xuICB9XG4gIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGRMID0geGQubGVuZ3RoO1xuICB5ZEwgPSB5ZC5sZW5ndGg7XG4gIGlmICh4ZEwgPCB5ZEwpIHtcbiAgICByID0geGQ7XG4gICAgeGQgPSB5ZDtcbiAgICB5ZCA9IHI7XG4gICAgckwgPSB4ZEw7XG4gICAgeGRMID0geWRMO1xuICAgIHlkTCA9IHJMO1xuICB9XG4gIHIgPSBbXTtcbiAgckwgPSB4ZEwgKyB5ZEw7XG4gIGZvciAoaSA9IHJMOyBpLS07IClcbiAgICByLnB1c2goMCk7XG4gIGZvciAoaSA9IHlkTDsgLS1pID49IDA7ICkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGsgPSB4ZEwgKyBpOyBrID4gaTsgKSB7XG4gICAgICB0ID0gcltrXSArIHlkW2ldICogeGRbayAtIGkgLSAxXSArIGNhcnJ5O1xuICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xuICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XG4gICAgfVxuICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xuICB9XG4gIGZvciAoOyAhclstLXJMXTsgKVxuICAgIHIucG9wKCk7XG4gIGlmIChjYXJyeSlcbiAgICArK2U7XG4gIGVsc2VcbiAgICByLnNoaWZ0KCk7XG4gIHkuZCA9IHI7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xufTtcblAudG9CaW5hcnkgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDIsIHNkLCBybSk7XG59O1xuUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoZHAgPT09IHZvaWQgMClcbiAgICByZXR1cm4geDtcbiAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gIGlmIChybSA9PT0gdm9pZCAwKVxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgZWxzZVxuICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XG59O1xuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gIHZhciBzdHIsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMClcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICBlbHNlXG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgMSwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUsIGRwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/IFwiLVwiICsgc3RyIDogc3RyO1xufTtcblAudG9GaXhlZCA9IGZ1bmN0aW9uKGRwLCBybSkge1xuICB2YXIgc3RyLCB5LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeSA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIHguZSArIDEsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh5LCBmYWxzZSwgZHAgKyB5LmUgKyAxKTtcbiAgfVxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24obWF4RCkge1xuICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgciwgeCA9IHRoaXMsIHhkID0geC5kLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4ZClcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIG4xID0gZDAgPSBuZXcgQ3RvcigxKTtcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xuICBkID0gbmV3IEN0b3IoZDEpO1xuICBlID0gZC5lID0gZ2V0UHJlY2lzaW9uKHhkKSAtIHguZSAtIDE7XG4gIGsgPSBlICUgTE9HX0JBU0U7XG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XG4gIGlmIChtYXhEID09IG51bGwpIHtcbiAgICBtYXhEID0gZSA+IDAgPyBkIDogbjE7XG4gIH0gZWxzZSB7XG4gICAgbiA9IG5ldyBDdG9yKG1heEQpO1xuICAgIGlmICghbi5pc0ludCgpIHx8IG4ubHQobjEpKVxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XG4gICAgbWF4RCA9IG4uZ3QoZCkgPyBlID4gMCA/IGQgOiBuMSA6IG47XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgbiA9IG5ldyBDdG9yKGRpZ2l0c1RvU3RyaW5nKHhkKSk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcbiAgZm9yICg7IDsgKSB7XG4gICAgcSA9IGRpdmlkZShuLCBkLCAwLCAxLCAxKTtcbiAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xuICAgIGlmIChkMi5jbXAobWF4RCkgPT0gMSlcbiAgICAgIGJyZWFrO1xuICAgIGQwID0gZDE7XG4gICAgZDEgPSBkMjtcbiAgICBkMiA9IG4xO1xuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XG4gICAgbjAgPSBkMjtcbiAgICBkMiA9IGQ7XG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xuICAgIG4gPSBkMjtcbiAgfVxuICBkMiA9IGRpdmlkZShtYXhELm1pbnVzKGQwKSwgZDEsIDAsIDEsIDEpO1xuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcbiAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XG4gIG4wLnMgPSBuMS5zID0geC5zO1xuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiByO1xufTtcblAudG9IZXhhZGVjaW1hbCA9IFAudG9IZXggPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDE2LCBzZCwgcm0pO1xufTtcblAudG9OZWFyZXN0ID0gZnVuY3Rpb24oeSwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgaWYgKCF4LmQpXG4gICAgICByZXR1cm4geDtcbiAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkge1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB9XG4gICAgaWYgKCF4LmQpXG4gICAgICByZXR1cm4geS5zID8geCA6IHk7XG4gICAgaWYgKCF5LmQpIHtcbiAgICAgIGlmICh5LnMpXG4gICAgICAgIHkucyA9IHgucztcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfVxuICBpZiAoeS5kWzBdKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB4ID0gZGl2aWRlKHgsIHksIDAsIHJtLCAxKS50aW1lcyh5KTtcbiAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgZmluYWxpc2UoeCk7XG4gIH0gZWxzZSB7XG4gICAgeS5zID0geC5zO1xuICAgIHggPSB5O1xuICB9XG4gIHJldHVybiB4O1xufTtcblAudG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICt0aGlzO1xufTtcblAudG9PY3RhbCA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgOCwgc2QsIHJtKTtcbn07XG5QLnRvUG93ZXIgPSBQLnBvdyA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGUsIGssIHByLCByLCBybSwgcywgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCB5biA9ICsoeSA9IG5ldyBDdG9yKHkpKTtcbiAgaWYgKCF4LmQgfHwgIXkuZCB8fCAheC5kWzBdIHx8ICF5LmRbMF0pXG4gICAgcmV0dXJuIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKHguZXEoMSkpXG4gICAgcmV0dXJuIHg7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKHkuZXEoMSkpXG4gICAgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSk7XG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICBpZiAoZSA+PSB5LmQubGVuZ3RoIC0gMSAmJiAoayA9IHluIDwgMCA/IC15biA6IHluKSA8PSBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgciA9IGludFBvdyhDdG9yLCB4LCBrLCBwcik7XG4gICAgcmV0dXJuIHkucyA8IDAgPyBuZXcgQ3RvcigxKS5kaXYocikgOiBmaW5hbGlzZShyLCBwciwgcm0pO1xuICB9XG4gIHMgPSB4LnM7XG4gIGlmIChzIDwgMCkge1xuICAgIGlmIChlIDwgeS5kLmxlbmd0aCAtIDEpXG4gICAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApXG4gICAgICBzID0gMTtcbiAgICBpZiAoeC5lID09IDAgJiYgeC5kWzBdID09IDEgJiYgeC5kLmxlbmd0aCA9PSAxKSB7XG4gICAgICB4LnMgPSBzO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG4gIGsgPSBtYXRocG93KCt4LCB5bik7XG4gIGUgPSBrID09IDAgfHwgIWlzRmluaXRlKGspID8gbWF0aGZsb29yKHluICogKE1hdGgubG9nKFwiMC5cIiArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpIDogbmV3IEN0b3IoayArIFwiXCIpLmU7XG4gIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSlcbiAgICByZXR1cm4gbmV3IEN0b3IoZSA+IDAgPyBzIC8gMCA6IDApO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBDdG9yLnJvdW5kaW5nID0geC5zID0gMTtcbiAgayA9IE1hdGgubWluKDEyLCAoZSArIFwiXCIpLmxlbmd0aCk7XG4gIHIgPSBuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIHByICsgaykpLCBwcik7XG4gIGlmIChyLmQpIHtcbiAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcbiAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIHByLCBybSkpIHtcbiAgICAgIGUgPSBwciArIDEwO1xuICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcbiAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XG4gICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByLnMgPSBzO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG59O1xuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uKHNkLCBybSkge1xuICB2YXIgc3RyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKVxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2VcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCBzZCA8PSB4LmUgfHwgeC5lIDw9IEN0b3IudG9FeHBOZWcsIHNkKTtcbiAgfVxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xufTtcblAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50cnVuY2F0ZWQgPSBQLnRydW5jID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XG59O1xuUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xuICB2YXIgaSwgaywgd3MsIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSwgc3RyID0gXCJcIiwgdyA9IGRbMF07XG4gIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XG4gICAgc3RyICs9IHc7XG4gICAgZm9yIChpID0gMTsgaSA8IGluZGV4T2ZMYXN0V29yZDsgaSsrKSB7XG4gICAgICB3cyA9IGRbaV0gKyBcIlwiO1xuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgICAgaWYgKGspXG4gICAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgc3RyICs9IHdzO1xuICAgIH1cbiAgICB3ID0gZFtpXTtcbiAgICB3cyA9IHcgKyBcIlwiO1xuICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcbiAgICBpZiAoaylcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2UgaWYgKHcgPT09IDApIHtcbiAgICByZXR1cm4gXCIwXCI7XG4gIH1cbiAgZm9yICg7IHcgJSAxMCA9PT0gMDsgKVxuICAgIHcgLz0gMTA7XG4gIHJldHVybiBzdHIgKyB3O1xufVxuX19uYW1lKGRpZ2l0c1RvU3RyaW5nLCBcImRpZ2l0c1RvU3RyaW5nXCIpO1xuX19uYW1lMihkaWdpdHNUb1N0cmluZywgXCJkaWdpdHNUb1N0cmluZ1wiKTtcbmZ1bmN0aW9uIGNoZWNrSW50MzIoaSwgbWluMiwgbWF4Mikge1xuICBpZiAoaSAhPT0gfn5pIHx8IGkgPCBtaW4yIHx8IGkgPiBtYXgyKSB7XG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgaSk7XG4gIH1cbn1cbl9fbmFtZShjaGVja0ludDMyLCBcImNoZWNrSW50MzJcIik7XG5fX25hbWUyKGNoZWNrSW50MzIsIFwiY2hlY2tJbnQzMlwiKTtcbmZ1bmN0aW9uIGNoZWNrUm91bmRpbmdEaWdpdHMoZCwgaSwgcm0sIHJlcGVhdGluZykge1xuICB2YXIgZGksIGssIHIsIHJkO1xuICBmb3IgKGsgPSBkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgIC0taTtcbiAgaWYgKC0taSA8IDApIHtcbiAgICBpICs9IExPR19CQVNFO1xuICAgIGRpID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgIGkgJT0gTE9HX0JBU0U7XG4gIH1cbiAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gIHJkID0gZFtkaV0gJSBrIHwgMDtcbiAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XG4gICAgaWYgKGkgPCAzKSB7XG4gICAgICBpZiAoaSA9PSAwKVxuICAgICAgICByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgcmQgPSByZCAvIDEwIHwgMDtcbiAgICAgIHIgPSBybSA8IDQgJiYgcmQgPT0gOTk5OTkgfHwgcm0gPiAzICYmIHJkID09IDQ5OTk5IHx8IHJkID09IDVlNCB8fCByZCA9PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKHJtIDwgNCAmJiByZCArIDEgPT0gayB8fCBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAyKSAtIDEgfHwgKHJkID09IGsgLyAyIHx8IHJkID09IDApICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkgPCA0KSB7XG4gICAgICBpZiAoaSA9PSAwKVxuICAgICAgICByZCA9IHJkIC8gMWUzIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSlcbiAgICAgICAgcmQgPSByZCAvIDEwMCB8IDA7XG4gICAgICBlbHNlIGlmIChpID09IDIpXG4gICAgICAgIHJkID0gcmQgLyAxMCB8IDA7XG4gICAgICByID0gKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkID09IDk5OTkgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgPT0gNDk5OTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDFlMyB8IDApID09IG1hdGhwb3coMTAsIGkgLSAzKSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuX19uYW1lKGNoZWNrUm91bmRpbmdEaWdpdHMsIFwiY2hlY2tSb3VuZGluZ0RpZ2l0c1wiKTtcbl9fbmFtZTIoY2hlY2tSb3VuZGluZ0RpZ2l0cywgXCJjaGVja1JvdW5kaW5nRGlnaXRzXCIpO1xuZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcbiAgdmFyIGosIGFyciA9IFswXSwgYXJyTCwgaSA9IDAsIHN0ckwgPSBzdHIubGVuZ3RoO1xuICBmb3IgKDsgaSA8IHN0ckw7ICkge1xuICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgKVxuICAgICAgYXJyW2FyckxdICo9IGJhc2VJbjtcbiAgICBhcnJbMF0gKz0gTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xuICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xuICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGFycltqICsgMV0gPSAwO1xuICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xuICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG59XG5fX25hbWUoY29udmVydEJhc2UsIFwiY29udmVydEJhc2VcIik7XG5fX25hbWUyKGNvbnZlcnRCYXNlLCBcImNvbnZlcnRCYXNlXCIpO1xuZnVuY3Rpb24gY29zaW5lKEN0b3IsIHgpIHtcbiAgdmFyIGssIGxlbiwgeTtcbiAgaWYgKHguaXNaZXJvKCkpXG4gICAgcmV0dXJuIHg7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzMikge1xuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XG4gICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMTY7XG4gICAgeSA9IFwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uICs9IGs7XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xuICBmb3IgKHZhciBpID0gazsgaS0tOyApIHtcbiAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xuICAgIHggPSBjb3MyeC50aW1lcyhjb3MyeCkubWludXMoY29zMngpLnRpbWVzKDgpLnBsdXMoMSk7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gLT0gaztcbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoY29zaW5lLCBcImNvc2luZVwiKTtcbl9fbmFtZTIoY29zaW5lLCBcImNvc2luZVwiKTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gbXVsdGlwbHlJbnRlZ2VyKHgsIGssIGJhc2UpIHtcbiAgICB2YXIgdGVtcCwgY2FycnkgPSAwLCBpID0geC5sZW5ndGg7XG4gICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07ICkge1xuICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XG4gICAgICB4W2ldID0gdGVtcCAlIGJhc2UgfCAwO1xuICAgICAgY2FycnkgPSB0ZW1wIC8gYmFzZSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSlcbiAgICAgIHgudW5zaGlmdChjYXJyeSk7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgX19uYW1lKG11bHRpcGx5SW50ZWdlciwgXCJtdWx0aXBseUludGVnZXJcIik7XG4gIF9fbmFtZTIobXVsdGlwbHlJbnRlZ2VyLCBcIm11bHRpcGx5SW50ZWdlclwiKTtcbiAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcbiAgICB2YXIgaSwgcjtcbiAgICBpZiAoYUwgIT0gYkwpIHtcbiAgICAgIHIgPSBhTCA+IGJMID8gMSA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xuICAgICAgICAgIHIgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBfX25hbWUoY29tcGFyZSwgXCJjb21wYXJlXCIpO1xuICBfX25hbWUyKGNvbXBhcmUsIFwiY29tcGFyZVwiKTtcbiAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGFMLS07ICkge1xuICAgICAgYVthTF0gLT0gaTtcbiAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XG4gICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcbiAgICB9XG4gICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgKVxuICAgICAgYS5zaGlmdCgpO1xuICB9XG4gIF9fbmFtZShzdWJ0cmFjdCwgXCJzdWJ0cmFjdFwiKTtcbiAgX19uYW1lMihzdWJ0cmFjdCwgXCJzdWJ0cmFjdFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHksIHByLCBybSwgZHAsIGJhc2UpIHtcbiAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLCB5TCwgeXosIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzaWduMiA9IHgucyA9PSB5LnMgPyAxIDogLTEsIHhkID0geC5kLCB5ZCA9IHkuZDtcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XG4gICAgICByZXR1cm4gbmV3IEN0b3IoIXgucyB8fCAheS5zIHx8ICh4ZCA/IHlkICYmIHhkWzBdID09IHlkWzBdIDogIXlkKSA/IE5hTiA6IHhkICYmIHhkWzBdID09IDAgfHwgIXlkID8gc2lnbjIgKiAwIDogc2lnbjIgLyAwKTtcbiAgICB9XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIGxvZ0Jhc2UgPSAxO1xuICAgICAgZSA9IHguZSAtIHkuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9IEJBU0U7XG4gICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XG4gICAgICBlID0gbWF0aGZsb29yKHguZSAvIGxvZ0Jhc2UpIC0gbWF0aGZsb29yKHkuZSAvIGxvZ0Jhc2UpO1xuICAgIH1cbiAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICB4TCA9IHhkLmxlbmd0aDtcbiAgICBxID0gbmV3IEN0b3Ioc2lnbjIpO1xuICAgIHFkID0gcS5kID0gW107XG4gICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspXG4gICAgICA7XG4gICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKVxuICAgICAgZS0tO1xuICAgIGlmIChwciA9PSBudWxsKSB7XG4gICAgICBzZCA9IHByID0gQ3Rvci5wcmVjaXNpb247XG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgfSBlbHNlIGlmIChkcCkge1xuICAgICAgc2QgPSBwciArICh4LmUgLSB5LmUpICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2QgPSBwcjtcbiAgICB9XG4gICAgaWYgKHNkIDwgMCkge1xuICAgICAgcWQucHVzaCgxKTtcbiAgICAgIG1vcmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZCA9IHNkIC8gbG9nQmFzZSArIDIgfCAwO1xuICAgICAgaSA9IDA7XG4gICAgICBpZiAoeUwgPT0gMSkge1xuICAgICAgICBrID0gMDtcbiAgICAgICAgeWQgPSB5ZFswXTtcbiAgICAgICAgc2QrKztcbiAgICAgICAgZm9yICg7IChpIDwgeEwgfHwgaykgJiYgc2QtLTsgaSsrKSB7XG4gICAgICAgICAgdCA9IGsgKiBiYXNlICsgKHhkW2ldIHx8IDApO1xuICAgICAgICAgIHFkW2ldID0gdCAvIHlkIHwgMDtcbiAgICAgICAgICBrID0gdCAlIHlkIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBtb3JlID0gayB8fCBpIDwgeEw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gYmFzZSAvICh5ZFswXSArIDEpIHwgMDtcbiAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgeWQgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xuICAgICAgICAgIHhkID0gbXVsdGlwbHlJbnRlZ2VyKHhkLCBrLCBiYXNlKTtcbiAgICAgICAgICB5TCA9IHlkLmxlbmd0aDtcbiAgICAgICAgICB4TCA9IHhkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB4aSA9IHlMO1xuICAgICAgICByZW0gPSB4ZC5zbGljZSgwLCB5TCk7XG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyApXG4gICAgICAgICAgcmVtW3JlbUwrK10gPSAwO1xuICAgICAgICB5eiA9IHlkLnNsaWNlKCk7XG4gICAgICAgIHl6LnVuc2hpZnQoMCk7XG4gICAgICAgIHlkMCA9IHlkWzBdO1xuICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpXG4gICAgICAgICAgKyt5ZDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcbiAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKVxuICAgICAgICAgICAgICByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xuICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChrID49IGJhc2UpXG4gICAgICAgICAgICAgICAgayA9IGJhc2UgLSAxO1xuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gMSkge1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5ZCwgcHJvZEwsIGJhc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoayA9PSAwKVxuICAgICAgICAgICAgICAgIGNtcCA9IGsgPSAxO1xuICAgICAgICAgICAgICBwcm9kID0geWQuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKVxuICAgICAgICAgICAgICBwcm9kLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgICAgICByZW0gPSBbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHFkW2krK10gPSBrO1xuICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcbiAgICAgICAgICAgIHJlbUwgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT09IHZvaWQgMCkgJiYgc2QtLSk7XG4gICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICghcWRbMF0pXG4gICAgICAgIHFkLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChsb2dCYXNlID09IDEpIHtcbiAgICAgIHEuZSA9IGU7XG4gICAgICBpbmV4YWN0ID0gbW9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICBpKys7XG4gICAgICBxLmUgPSBpICsgZSAqIGxvZ0Jhc2UgLSAxO1xuICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIGZpbmFsaXNlKHgsIHNkLCBybSwgaXNUcnVuY2F0ZWQpIHtcbiAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBvdXQ6XG4gICAgaWYgKHNkICE9IG51bGwpIHtcbiAgICAgIHhkID0geC5kO1xuICAgICAgaWYgKCF4ZClcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICBmb3IgKGRpZ2l0cyA9IDEsIGsgPSB4ZFswXTsgayA+PSAxMDsgayAvPSAxMClcbiAgICAgICAgZGlnaXRzKys7XG4gICAgICBpID0gc2QgLSBkaWdpdHM7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICAgICAgaiA9IHNkO1xuICAgICAgICB3ID0geGRbeGRpID0gMF07XG4gICAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgICAgICBrID0geGQubGVuZ3RoO1xuICAgICAgICBpZiAoeGRpID49IGspIHtcbiAgICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoOyBrKysgPD0geGRpOyApXG4gICAgICAgICAgICAgIHhkLnB1c2goMCk7XG4gICAgICAgICAgICB3ID0gcmQgPSAwO1xuICAgICAgICAgICAgZGlnaXRzID0gMTtcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XG4gICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWsgb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ID0gayA9IHhkW3hkaV07XG4gICAgICAgICAgZm9yIChkaWdpdHMgPSAxOyBrID49IDEwOyBrIC89IDEwKVxuICAgICAgICAgICAgZGlnaXRzKys7XG4gICAgICAgICAgaSAlPSBMT0dfQkFTRTtcbiAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xuICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNUcnVuY2F0ZWQgPSBpc1RydW5jYXRlZCB8fCBzZCA8IDAgfHwgeGRbeGRpICsgMV0gIT09IHZvaWQgMCB8fCAoaiA8IDAgPyB3IDogdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSk7XG4gICAgICByb3VuZFVwID0gcm0gPCA0ID8gKHJkIHx8IGlzVHJ1bmNhdGVkKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSkgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCBpc1RydW5jYXRlZCB8fCBybSA9PSA2ICYmIChpID4gMCA/IGogPiAwID8gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopIDogMCA6IHhkW3hkaSAtIDFdKSAlIDEwICYgMSB8fCBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XG4gICAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xuICAgICAgICB4ZC5sZW5ndGggPSAwO1xuICAgICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICAgIHNkIC09IHguZSArIDE7XG4gICAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcbiAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ZFswXSA9IHguZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaTtcbiAgICAgICAgayA9IDE7XG4gICAgICAgIHhkaS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGQubGVuZ3RoID0geGRpICsgMTtcbiAgICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gICAgICAgIHhkW3hkaV0gPSBqID4gMCA/ICh3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgJSBtYXRocG93KDEwLCBqKSB8IDApICogayA6IDA7XG4gICAgICB9XG4gICAgICBpZiAocm91bmRVcCkge1xuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBpZiAoeGRpID09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4ZFswXTsgaiA+PSAxMDsgaiAvPSAxMClcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaiA9IHhkWzBdICs9IGs7XG4gICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwKVxuICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICBpZiAoaSAhPSBrKSB7XG4gICAgICAgICAgICAgIHguZSsrO1xuICAgICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSlcbiAgICAgICAgICAgICAgICB4ZFswXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGRbeGRpXSArPSBrO1xuICAgICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB4ZFt4ZGktLV0gPSAwO1xuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7IClcbiAgICAgICAgeGQucG9wKCk7XG4gICAgfVxuICBpZiAoZXh0ZXJuYWwpIHtcbiAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XG4gICAgICB4LmQgPSBudWxsO1xuICAgICAgeC5lID0gTmFOO1xuICAgIH0gZWxzZSBpZiAoeC5lIDwgQ3Rvci5taW5FKSB7XG4gICAgICB4LmUgPSAwO1xuICAgICAgeC5kID0gWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cbl9fbmFtZShmaW5hbGlzZSwgXCJmaW5hbGlzZVwiKTtcbl9fbmFtZTIoZmluYWxpc2UsIFwiZmluYWxpc2VcIik7XG5mdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcbiAgaWYgKCF4LmlzRmluaXRlKCkpXG4gICAgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xuICB2YXIgaywgZSA9IHguZSwgc3RyID0gZGlnaXRzVG9TdHJpbmcoeC5kKSwgbGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xuICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcbiAgICB9IGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyBcImVcIiA6IFwiZStcIikgKyB4LmU7XG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICBzdHIgPSBcIjAuXCIgKyBnZXRaZXJvU3RyaW5nKC1lIC0gMSkgKyBzdHI7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMClcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XG4gICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gZSAtIDEpID4gMClcbiAgICAgIHN0ciA9IHN0ciArIFwiLlwiICsgZ2V0WmVyb1N0cmluZyhrKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoKGsgPSBlICsgMSkgPCBsZW4pXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyBcIi5cIiArIHN0ci5zbGljZShrKTtcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XG4gICAgICBpZiAoZSArIDEgPT09IGxlbilcbiAgICAgICAgc3RyICs9IFwiLlwiO1xuICAgICAgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5fX25hbWUoZmluaXRlVG9TdHJpbmcsIFwiZmluaXRlVG9TdHJpbmdcIik7XG5fX25hbWUyKGZpbml0ZVRvU3RyaW5nLCBcImZpbml0ZVRvU3RyaW5nXCIpO1xuZnVuY3Rpb24gZ2V0QmFzZTEwRXhwb25lbnQoZGlnaXRzLCBlKSB7XG4gIHZhciB3ID0gZGlnaXRzWzBdO1xuICBmb3IgKGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApXG4gICAgZSsrO1xuICByZXR1cm4gZTtcbn1cbl9fbmFtZShnZXRCYXNlMTBFeHBvbmVudCwgXCJnZXRCYXNlMTBFeHBvbmVudFwiKTtcbl9fbmFtZTIoZ2V0QmFzZTEwRXhwb25lbnQsIFwiZ2V0QmFzZTEwRXhwb25lbnRcIik7XG5mdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xuICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xuICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICBpZiAocHIpXG4gICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihMTjEwKSwgc2QsIDEsIHRydWUpO1xufVxuX19uYW1lKGdldExuMTAsIFwiZ2V0TG4xMFwiKTtcbl9fbmFtZTIoZ2V0TG4xMCwgXCJnZXRMbjEwXCIpO1xuZnVuY3Rpb24gZ2V0UGkoQ3Rvciwgc2QsIHJtKSB7XG4gIGlmIChzZCA+IFBJX1BSRUNJU0lPTilcbiAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcbn1cbl9fbmFtZShnZXRQaSwgXCJnZXRQaVwiKTtcbl9fbmFtZTIoZ2V0UGksIFwiZ2V0UGlcIik7XG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oZGlnaXRzKSB7XG4gIHZhciB3ID0gZGlnaXRzLmxlbmd0aCAtIDEsIGxlbiA9IHcgKiBMT0dfQkFTRSArIDE7XG4gIHcgPSBkaWdpdHNbd107XG4gIGlmICh3KSB7XG4gICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKVxuICAgICAgbGVuLS07XG4gICAgZm9yICh3ID0gZGlnaXRzWzBdOyB3ID49IDEwOyB3IC89IDEwKVxuICAgICAgbGVuKys7XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbl9fbmFtZShnZXRQcmVjaXNpb24sIFwiZ2V0UHJlY2lzaW9uXCIpO1xuX19uYW1lMihnZXRQcmVjaXNpb24sIFwiZ2V0UHJlY2lzaW9uXCIpO1xuZnVuY3Rpb24gZ2V0WmVyb1N0cmluZyhrKSB7XG4gIHZhciB6cyA9IFwiXCI7XG4gIGZvciAoOyBrLS07IClcbiAgICB6cyArPSBcIjBcIjtcbiAgcmV0dXJuIHpzO1xufVxuX19uYW1lKGdldFplcm9TdHJpbmcsIFwiZ2V0WmVyb1N0cmluZ1wiKTtcbl9fbmFtZTIoZ2V0WmVyb1N0cmluZywgXCJnZXRaZXJvU3RyaW5nXCIpO1xuZnVuY3Rpb24gaW50UG93KEN0b3IsIHgsIG4sIHByKSB7XG4gIHZhciBpc1RydW5jYXRlZCwgciA9IG5ldyBDdG9yKDEpLCBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UgKyA0KTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yICg7IDsgKSB7XG4gICAgaWYgKG4gJSAyKSB7XG4gICAgICByID0gci50aW1lcyh4KTtcbiAgICAgIGlmICh0cnVuY2F0ZShyLmQsIGspKVxuICAgICAgICBpc1RydW5jYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIG4gPSBtYXRoZmxvb3IobiAvIDIpO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBuID0gci5kLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaXNUcnVuY2F0ZWQgJiYgci5kW25dID09PSAwKVxuICAgICAgICArK3IuZFtuXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB4ID0geC50aW1lcyh4KTtcbiAgICB0cnVuY2F0ZSh4LmQsIGspO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHI7XG59XG5fX25hbWUoaW50UG93LCBcImludFBvd1wiKTtcbl9fbmFtZTIoaW50UG93LCBcImludFBvd1wiKTtcbmZ1bmN0aW9uIGlzT2RkKG4pIHtcbiAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xufVxuX19uYW1lKGlzT2RkLCBcImlzT2RkXCIpO1xuX19uYW1lMihpc09kZCwgXCJpc09kZFwiKTtcbmZ1bmN0aW9uIG1heE9yTWluKEN0b3IsIGFyZ3MsIGx0Z3QpIHtcbiAgdmFyIHksIHggPSBuZXcgQ3RvcihhcmdzWzBdKSwgaSA9IDA7XG4gIGZvciAoOyArK2kgPCBhcmdzLmxlbmd0aDsgKSB7XG4gICAgeSA9IG5ldyBDdG9yKGFyZ3NbaV0pO1xuICAgIGlmICgheS5zKSB7XG4gICAgICB4ID0geTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoeFtsdGd0XSh5KSkge1xuICAgICAgeCA9IHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKG1heE9yTWluLCBcIm1heE9yTWluXCIpO1xuX19uYW1lMihtYXhPck1pbiwgXCJtYXhPck1pblwiKTtcbmZ1bmN0aW9uIG5hdHVyYWxFeHBvbmVudGlhbCh4LCBzZCkge1xuICB2YXIgZGVub21pbmF0b3IsIGd1YXJkLCBqLCBwb3cyLCBzdW0yLCB0LCB3cHIsIHJlcCA9IDAsIGkgPSAwLCBrID0gMCwgQ3RvciA9IHguY29uc3RydWN0b3IsIHJtID0gQ3Rvci5yb3VuZGluZywgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgaWYgKCF4LmQgfHwgIXguZFswXSB8fCB4LmUgPiAxNykge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4LmQgPyAheC5kWzBdID8gMSA6IHgucyA8IDAgPyAwIDogMSAvIDAgOiB4LnMgPyB4LnMgPCAwID8gMCA6IHggOiAwIC8gMCk7XG4gIH1cbiAgaWYgKHNkID09IG51bGwpIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHdwciA9IHByO1xuICB9IGVsc2Uge1xuICAgIHdwciA9IHNkO1xuICB9XG4gIHQgPSBuZXcgQ3RvcigwLjAzMTI1KTtcbiAgd2hpbGUgKHguZSA+IC0yKSB7XG4gICAgeCA9IHgudGltZXModCk7XG4gICAgayArPSA1O1xuICB9XG4gIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XG4gIHdwciArPSBndWFyZDtcbiAgZGVub21pbmF0b3IgPSBwb3cyID0gc3VtMiA9IG5ldyBDdG9yKDEpO1xuICBDdG9yLnByZWNpc2lvbiA9IHdwcjtcbiAgZm9yICg7IDsgKSB7XG4gICAgcG93MiA9IGZpbmFsaXNlKHBvdzIudGltZXMoeCksIHdwciwgMSk7XG4gICAgZGVub21pbmF0b3IgPSBkZW5vbWluYXRvci50aW1lcygrK2kpO1xuICAgIHQgPSBzdW0yLnBsdXMoZGl2aWRlKHBvdzIsIGRlbm9taW5hdG9yLCB3cHIsIDEpKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCB3cHIpID09PSBkaWdpdHNUb1N0cmluZyhzdW0yLmQpLnNsaWNlKDAsIHdwcikpIHtcbiAgICAgIGogPSBrO1xuICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgc3VtMiA9IGZpbmFsaXNlKHN1bTIudGltZXMoc3VtMiksIHdwciwgMSk7XG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xuICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bTIuZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSBwb3cyID0gdCA9IG5ldyBDdG9yKDEpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHJlcCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0yLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgcmV0dXJuIHN1bTI7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bTIgPSB0O1xuICB9XG59XG5fX25hbWUobmF0dXJhbEV4cG9uZW50aWFsLCBcIm5hdHVyYWxFeHBvbmVudGlhbFwiKTtcbl9fbmFtZTIobmF0dXJhbEV4cG9uZW50aWFsLCBcIm5hdHVyYWxFeHBvbmVudGlhbFwiKTtcbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcbiAgdmFyIGMsIGMwLCBkZW5vbWluYXRvciwgZSwgbnVtZXJhdG9yLCByZXAsIHN1bTIsIHQsIHdwciwgeDEsIHgyLCBuID0gMSwgZ3VhcmQgPSAxMCwgeCA9IHksIHhkID0geC5kLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBpZiAoeC5zIDwgMCB8fCAheGQgfHwgIXhkWzBdIHx8ICF4LmUgJiYgeGRbMF0gPT0gMSAmJiB4ZC5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4ZCAmJiAheGRbMF0gPyAtMSAvIDAgOiB4LnMgIT0gMSA/IE5hTiA6IHhkID8gMCA6IHgpO1xuICB9XG4gIGlmIChzZCA9PSBudWxsKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB3cHIgPSBwcjtcbiAgfSBlbHNlIHtcbiAgICB3cHIgPSBzZDtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcbiAgYzAgPSBjLmNoYXJBdCgwKTtcbiAgaWYgKE1hdGguYWJzKGUgPSB4LmUpIDwgMTVlMTQpIHtcbiAgICB3aGlsZSAoYzAgPCA3ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDMpIHtcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xuICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XG4gICAgICBjMCA9IGMuY2hhckF0KDApO1xuICAgICAgbisrO1xuICAgIH1cbiAgICBlID0geC5lO1xuICAgIGlmIChjMCA+IDEpIHtcbiAgICAgIHggPSBuZXcgQ3RvcihcIjAuXCIgKyBjKTtcbiAgICAgIGUrKztcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IG5ldyBDdG9yKGMwICsgXCIuXCIgKyBjLnNsaWNlKDEpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKTtcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArIFwiLlwiICsgYy5zbGljZSgxKSksIHdwciAtIGd1YXJkKS5wbHVzKHQpO1xuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xuICB9XG4gIHgxID0geDtcbiAgc3VtMiA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeC5taW51cygxKSwgeC5wbHVzKDEpLCB3cHIsIDEpO1xuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gIGRlbm9taW5hdG9yID0gMztcbiAgZm9yICg7IDsgKSB7XG4gICAgbnVtZXJhdG9yID0gZmluYWxpc2UobnVtZXJhdG9yLnRpbWVzKHgyKSwgd3ByLCAxKTtcbiAgICB0ID0gc3VtMi5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtMi5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICBzdW0yID0gc3VtMi50aW1lcygyKTtcbiAgICAgIGlmIChlICE9PSAwKVxuICAgICAgICBzdW0yID0gc3VtMi5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKSk7XG4gICAgICBzdW0yID0gZGl2aWRlKHN1bTIsIG5ldyBDdG9yKG4pLCB3cHIsIDEpO1xuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtMi5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcbiAgICAgICAgICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSByZXAgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0yLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgcmV0dXJuIHN1bTI7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bTIgPSB0O1xuICAgIGRlbm9taW5hdG9yICs9IDI7XG4gIH1cbn1cbl9fbmFtZShuYXR1cmFsTG9nYXJpdGhtLCBcIm5hdHVyYWxMb2dhcml0aG1cIik7XG5fX25hbWUyKG5hdHVyYWxMb2dhcml0aG0sIFwibmF0dXJhbExvZ2FyaXRobVwiKTtcbmZ1bmN0aW9uIG5vbkZpbml0ZVRvU3RyaW5nKHgpIHtcbiAgcmV0dXJuIFN0cmluZyh4LnMgKiB4LnMgLyAwKTtcbn1cbl9fbmFtZShub25GaW5pdGVUb1N0cmluZywgXCJub25GaW5pdGVUb1N0cmluZ1wiKTtcbl9fbmFtZTIobm9uRmluaXRlVG9TdHJpbmcsIFwibm9uRmluaXRlVG9TdHJpbmdcIik7XG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoeCwgc3RyKSB7XG4gIHZhciBlLCBpLCBsZW47XG4gIGlmICgoZSA9IHN0ci5pbmRleE9mKFwiLlwiKSkgPiAtMSlcbiAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xuICAgIGlmIChlIDwgMClcbiAgICAgIGUgPSBpO1xuICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgIGUgPSBzdHIubGVuZ3RoO1xuICB9XG4gIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKVxuICAgIDtcbiAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdChsZW4gLSAxKSA9PT0gNDg7IC0tbGVuKVxuICAgIDtcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XG4gIGlmIChzdHIpIHtcbiAgICBsZW4gLT0gaTtcbiAgICB4LmUgPSBlID0gZSAtIGkgLSAxO1xuICAgIHguZCA9IFtdO1xuICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgaSArPSBMT0dfQkFTRTtcbiAgICBpZiAoaSA8IGxlbikge1xuICAgICAgaWYgKGkpXG4gICAgICAgIHguZC5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xuICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47IClcbiAgICAgICAgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XG4gICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpIC09IGxlbjtcbiAgICB9XG4gICAgZm9yICg7IGktLTsgKVxuICAgICAgc3RyICs9IFwiMFwiO1xuICAgIHguZC5wdXNoKCtzdHIpO1xuICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICB4LmUgPSBOYU47XG4gICAgICB9IGVsc2UgaWYgKHguZSA8IHguY29uc3RydWN0b3IubWluRSkge1xuICAgICAgICB4LmUgPSAwO1xuICAgICAgICB4LmQgPSBbMF07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHguZSA9IDA7XG4gICAgeC5kID0gWzBdO1xuICB9XG4gIHJldHVybiB4O1xufVxuX19uYW1lKHBhcnNlRGVjaW1hbCwgXCJwYXJzZURlY2ltYWxcIik7XG5fX25hbWUyKHBhcnNlRGVjaW1hbCwgXCJwYXJzZURlY2ltYWxcIik7XG5mdW5jdGlvbiBwYXJzZU90aGVyKHgsIHN0cikge1xuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XG4gIGlmIChzdHIuaW5kZXhPZihcIl9cIikgPiAtMSkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csIFwiJDFcIik7XG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpXG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHN0cik7XG4gIH0gZWxzZSBpZiAoc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIk5hTlwiKSB7XG4gICAgaWYgKCErc3RyKVxuICAgICAgeC5zID0gTmFOO1xuICAgIHguZSA9IE5hTjtcbiAgICB4LmQgPSBudWxsO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmIChpc0hleC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoaXNCaW5hcnkudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDI7XG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpIHtcbiAgICBiYXNlID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBzdHIpO1xuICB9XG4gIGkgPSBzdHIuc2VhcmNoKC9wL2kpO1xuICBpZiAoaSA+IDApIHtcbiAgICBwID0gK3N0ci5zbGljZShpICsgMSk7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMik7XG4gIH1cbiAgaSA9IHN0ci5pbmRleE9mKFwiLlwiKTtcbiAgaXNGbG9hdCA9IGkgPj0gMDtcbiAgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmIChpc0Zsb2F0KSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xuICAgIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaSA9IGxlbiAtIGk7XG4gICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xuICB9XG4gIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBCQVNFKTtcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xuICBmb3IgKGkgPSB4ZTsgeGRbaV0gPT09IDA7IC0taSlcbiAgICB4ZC5wb3AoKTtcbiAgaWYgKGkgPCAwKVxuICAgIHJldHVybiBuZXcgQ3Rvcih4LnMgKiAwKTtcbiAgeC5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIHhlKTtcbiAgeC5kID0geGQ7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGlmIChpc0Zsb2F0KVxuICAgIHggPSBkaXZpZGUoeCwgZGl2aXNvciwgbGVuICogNCk7XG4gIGlmIChwKVxuICAgIHggPSB4LnRpbWVzKE1hdGguYWJzKHApIDwgNTQgPyBtYXRocG93KDIsIHApIDogRGVjaW1hbC5wb3coMiwgcCkpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB4O1xufVxuX19uYW1lKHBhcnNlT3RoZXIsIFwicGFyc2VPdGhlclwiKTtcbl9fbmFtZTIocGFyc2VPdGhlciwgXCJwYXJzZU90aGVyXCIpO1xuZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XG4gIHZhciBrLCBsZW4gPSB4LmQubGVuZ3RoO1xuICBpZiAobGVuIDwgMykge1xuICAgIHJldHVybiB4LmlzWmVybygpID8geCA6IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcbiAgfVxuICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xuICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XG4gIHZhciBzaW4yX3gsIGQ1ID0gbmV3IEN0b3IoNSksIGQxNiA9IG5ldyBDdG9yKDE2KSwgZDIwID0gbmV3IEN0b3IoMjApO1xuICBmb3IgKDsgay0tOyApIHtcbiAgICBzaW4yX3ggPSB4LnRpbWVzKHgpO1xuICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luMl94LnRpbWVzKGQxNi50aW1lcyhzaW4yX3gpLm1pbnVzKGQyMCkpKSk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5fX25hbWUoc2luZSwgXCJzaW5lXCIpO1xuX19uYW1lMihzaW5lLCBcInNpbmVcIik7XG5mdW5jdGlvbiB0YXlsb3JTZXJpZXMoQ3RvciwgbiwgeCwgeSwgaXNIeXBlcmJvbGljKSB7XG4gIHZhciBqLCB0LCB1LCB4MiwgaSA9IDEsIHByID0gQ3Rvci5wcmVjaXNpb24sIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHgyID0geC50aW1lcyh4KTtcbiAgdSA9IG5ldyBDdG9yKHkpO1xuICBmb3IgKDsgOyApIHtcbiAgICB0ID0gZGl2aWRlKHUudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XG4gICAgeSA9IGRpdmlkZSh0LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xuICAgIHQgPSB1LnBsdXMoeSk7XG4gICAgaWYgKHQuZFtrXSAhPT0gdm9pZCAwKSB7XG4gICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07IClcbiAgICAgICAgO1xuICAgICAgaWYgKGogPT0gLTEpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBqID0gdTtcbiAgICB1ID0geTtcbiAgICB5ID0gdDtcbiAgICB0ID0gajtcbiAgICBpKys7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICB0LmQubGVuZ3RoID0gayArIDE7XG4gIHJldHVybiB0O1xufVxuX19uYW1lKHRheWxvclNlcmllcywgXCJ0YXlsb3JTZXJpZXNcIik7XG5fX25hbWUyKHRheWxvclNlcmllcywgXCJ0YXlsb3JTZXJpZXNcIik7XG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcbiAgdmFyIG4gPSBiO1xuICB3aGlsZSAoLS1lKVxuICAgIG4gKj0gYjtcbiAgcmV0dXJuIG47XG59XG5fX25hbWUodGlueVBvdywgXCJ0aW55UG93XCIpO1xuX19uYW1lMih0aW55UG93LCBcInRpbnlQb3dcIik7XG5mdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcbiAgdmFyIHQsIGlzTmVnID0geC5zIDwgMCwgcGkgPSBnZXRQaShDdG9yLCBDdG9yLnByZWNpc2lvbiwgMSksIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XG4gIHggPSB4LmFicygpO1xuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0ID0geC5kaXZUb0ludChwaSk7XG4gIGlmICh0LmlzWmVybygpKSB7XG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDMgOiAyO1xuICB9IGVsc2Uge1xuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcbiAgICBpZiAoeC5sdGUoaGFsZlBpKSkge1xuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IGlzTmVnID8gMiA6IDMgOiBpc05lZyA/IDQgOiAxO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDEgOiA0IDogaXNOZWcgPyAzIDogMjtcbiAgfVxuICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XG59XG5fX25hbWUodG9MZXNzVGhhbkhhbGZQaSwgXCJ0b0xlc3NUaGFuSGFsZlBpXCIpO1xuX19uYW1lMih0b0xlc3NUaGFuSGFsZlBpLCBcInRvTGVzc1RoYW5IYWxmUGlcIik7XG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcbiAgdmFyIGJhc2UsIGUsIGksIGssIGxlbiwgcm91bmRVcCwgc3RyLCB4ZCwgeSwgQ3RvciA9IHguY29uc3RydWN0b3IsIGlzRXhwID0gc2QgIT09IHZvaWQgMDtcbiAgaWYgKGlzRXhwKSB7XG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gICAgaWYgKHJtID09PSB2b2lkIDApXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZVxuICAgICAgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIH0gZWxzZSB7XG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIH1cbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcbiAgICBpID0gc3RyLmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpc0V4cCkge1xuICAgICAgYmFzZSA9IDI7XG4gICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xuICAgICAgICBzZCA9IHNkICogNCAtIDM7XG4gICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xuICAgICAgICBzZCA9IHNkICogMyAtIDI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBiYXNlT3V0O1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgICB5LmUgPSBzdHIubGVuZ3RoIC0gaTtcbiAgICAgIHkuZCA9IGNvbnZlcnRCYXNlKGZpbml0ZVRvU3RyaW5nKHkpLCAxMCwgYmFzZSk7XG4gICAgICB5LmUgPSB5LmQubGVuZ3RoO1xuICAgIH1cbiAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xuICAgIGUgPSBsZW4gPSB4ZC5sZW5ndGg7XG4gICAgZm9yICg7IHhkWy0tbGVuXSA9PSAwOyApXG4gICAgICB4ZC5wb3AoKTtcbiAgICBpZiAoIXhkWzBdKSB7XG4gICAgICBzdHIgPSBpc0V4cCA/IFwiMHArMFwiIDogXCIwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICBlLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gbmV3IEN0b3IoeCk7XG4gICAgICAgIHguZCA9IHhkO1xuICAgICAgICB4LmUgPSBlO1xuICAgICAgICB4ID0gZGl2aWRlKHgsIHksIHNkLCBybSwgMCwgYmFzZSk7XG4gICAgICAgIHhkID0geC5kO1xuICAgICAgICBlID0geC5lO1xuICAgICAgICByb3VuZFVwID0gaW5leGFjdDtcbiAgICAgIH1cbiAgICAgIGkgPSB4ZFtzZF07XG4gICAgICBrID0gYmFzZSAvIDI7XG4gICAgICByb3VuZFVwID0gcm91bmRVcCB8fCB4ZFtzZCArIDFdICE9PSB2b2lkIDA7XG4gICAgICByb3VuZFVwID0gcm0gPCA0ID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKSA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHwgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xuICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgZm9yICg7ICsreGRbLS1zZF0gPiBiYXNlIC0gMTsgKSB7XG4gICAgICAgICAgeGRbc2RdID0gMDtcbiAgICAgICAgICBpZiAoIXNkKSB7XG4gICAgICAgICAgICArK2U7XG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pXG4gICAgICAgIDtcbiAgICAgIGZvciAoaSA9IDAsIHN0ciA9IFwiXCI7IGkgPCBsZW47IGkrKylcbiAgICAgICAgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICBpZiAoaXNFeHApIHtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNiB8fCBiYXNlT3V0ID09IDgpIHtcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XG4gICAgICAgICAgICBmb3IgKC0tbGVuOyBsZW4gJSBpOyBsZW4rKylcbiAgICAgICAgICAgICAgc3RyICs9IFwiMFwiO1xuICAgICAgICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIGJhc2VPdXQpO1xuICAgICAgICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIHN0ciA9IFwiMS5cIjsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIFwiLlwiICsgc3RyLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBzdHIgKyAoZSA8IDAgPyBcInBcIiA6IFwicCtcIikgKyBlO1xuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xuICAgICAgICBmb3IgKDsgKytlOyApXG4gICAgICAgICAgc3RyID0gXCIwXCIgKyBzdHI7XG4gICAgICAgIHN0ciA9IFwiMC5cIiArIHN0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgrK2UgPiBsZW4pXG4gICAgICAgICAgZm9yIChlIC09IGxlbjsgZS0tOyApXG4gICAgICAgICAgICBzdHIgKz0gXCIwXCI7XG4gICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pXG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgXCIuXCIgKyBzdHIuc2xpY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gXCIweFwiIDogYmFzZU91dCA9PSAyID8gXCIwYlwiIDogYmFzZU91dCA9PSA4ID8gXCIwb1wiIDogXCJcIikgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHgucyA8IDAgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn1cbl9fbmFtZSh0b1N0cmluZ0JpbmFyeSwgXCJ0b1N0cmluZ0JpbmFyeVwiKTtcbl9fbmFtZTIodG9TdHJpbmdCaW5hcnksIFwidG9TdHJpbmdCaW5hcnlcIik7XG5mdW5jdGlvbiB0cnVuY2F0ZShhcnIsIGxlbikge1xuICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xuICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbl9fbmFtZSh0cnVuY2F0ZSwgXCJ0cnVuY2F0ZVwiKTtcbl9fbmFtZTIodHJ1bmNhdGUsIFwidHJ1bmNhdGVcIik7XG5mdW5jdGlvbiBhYnMoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWJzKCk7XG59XG5fX25hbWUoYWJzLCBcImFic1wiKTtcbl9fbmFtZTIoYWJzLCBcImFic1wiKTtcbmZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvcygpO1xufVxuX19uYW1lKGFjb3MsIFwiYWNvc1wiKTtcbl9fbmFtZTIoYWNvcywgXCJhY29zXCIpO1xuZnVuY3Rpb24gYWNvc2goeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvc2goKTtcbn1cbl9fbmFtZShhY29zaCwgXCJhY29zaFwiKTtcbl9fbmFtZTIoYWNvc2gsIFwiYWNvc2hcIik7XG5mdW5jdGlvbiBhZGQoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcbn1cbl9fbmFtZShhZGQsIFwiYWRkXCIpO1xuX19uYW1lMihhZGQsIFwiYWRkXCIpO1xuZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XG59XG5fX25hbWUoYXNpbiwgXCJhc2luXCIpO1xuX19uYW1lMihhc2luLCBcImFzaW5cIik7XG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luaCgpO1xufVxuX19uYW1lKGFzaW5oLCBcImFzaW5oXCIpO1xuX19uYW1lMihhc2luaCwgXCJhc2luaFwiKTtcbmZ1bmN0aW9uIGF0YW4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbigpO1xufVxuX19uYW1lKGF0YW4sIFwiYXRhblwiKTtcbl9fbmFtZTIoYXRhbiwgXCJhdGFuXCIpO1xuZnVuY3Rpb24gYXRhbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcbn1cbl9fbmFtZShhdGFuaCwgXCJhdGFuaFwiKTtcbl9fbmFtZTIoYXRhbmgsIFwiYXRhbmhcIik7XG5mdW5jdGlvbiBhdGFuMih5LCB4KSB7XG4gIHkgPSBuZXcgdGhpcyh5KTtcbiAgeCA9IG5ldyB0aGlzKHgpO1xuICB2YXIgciwgcHIgPSB0aGlzLnByZWNpc2lvbiwgcm0gPSB0aGlzLnJvdW5kaW5nLCB3cHIgPSBwciArIDQ7XG4gIGlmICgheS5zIHx8ICF4LnMpIHtcbiAgICByID0gbmV3IHRoaXMoTmFOKTtcbiAgfSBlbHNlIGlmICgheS5kICYmICF4LmQpIHtcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcbiAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoIXkuZCB8fCB4LmlzWmVybygpKSB7XG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoeC5zIDwgMCkge1xuICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xuICAgIHRoaXMucm91bmRpbmcgPSAxO1xuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XG4gICAgdGhpcy5yb3VuZGluZyA9IHJtO1xuICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcbiAgfSBlbHNlIHtcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbl9fbmFtZShhdGFuMiwgXCJhdGFuMlwiKTtcbl9fbmFtZTIoYXRhbjIsIFwiYXRhbjJcIik7XG5mdW5jdGlvbiBjYnJ0KHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcbn1cbl9fbmFtZShjYnJ0LCBcImNicnRcIik7XG5fX25hbWUyKGNicnQsIFwiY2JydFwiKTtcbmZ1bmN0aW9uIGNlaWwoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcbn1cbl9fbmFtZShjZWlsLCBcImNlaWxcIik7XG5fX25hbWUyKGNlaWwsIFwiY2VpbFwiKTtcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbjIsIG1heDIpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNsYW1wKG1pbjIsIG1heDIpO1xufVxuX19uYW1lKGNsYW1wLCBcImNsYW1wXCIpO1xuX19uYW1lMihjbGFtcCwgXCJjbGFtcFwiKTtcbmZ1bmN0aW9uIGNvbmZpZyhvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIilcbiAgICB0aHJvdyBFcnJvcihkZWNpbWFsRXJyb3IgKyBcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgdmFyIGksIHAsIHYsIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLCBwcyA9IFtcbiAgICBcInByZWNpc2lvblwiLFxuICAgIDEsXG4gICAgTUFYX0RJR0lUUyxcbiAgICBcInJvdW5kaW5nXCIsXG4gICAgMCxcbiAgICA4LFxuICAgIFwidG9FeHBOZWdcIixcbiAgICAtRVhQX0xJTUlULFxuICAgIDAsXG4gICAgXCJ0b0V4cFBvc1wiLFxuICAgIDAsXG4gICAgRVhQX0xJTUlULFxuICAgIFwibWF4RVwiLFxuICAgIDAsXG4gICAgRVhQX0xJTUlULFxuICAgIFwibWluRVwiLFxuICAgIC1FWFBfTElNSVQsXG4gICAgMCxcbiAgICBcIm1vZHVsb1wiLFxuICAgIDAsXG4gICAgOVxuICBdO1xuICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBpZiAocCA9IHBzW2ldLCB1c2VEZWZhdWx0cylcbiAgICAgIHRoaXNbcF0gPSBERUZBVUxUU1twXTtcbiAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChtYXRoZmxvb3IodikgPT09IHYgJiYgdiA+PSBwc1tpICsgMV0gJiYgdiA8PSBwc1tpICsgMl0pXG4gICAgICAgIHRoaXNbcF0gPSB2O1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgXCI6IFwiICsgdik7XG4gICAgfVxuICB9XG4gIGlmIChwID0gXCJjcnlwdG9cIiwgdXNlRGVmYXVsdHMpXG4gICAgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xuICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZSB8fCB2ID09PSAwIHx8IHYgPT09IDEpIHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9IFwidW5kZWZpbmVkXCIgJiYgY3J5cHRvICYmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgICAgICB0aGlzW3BdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArIFwiOiBcIiArIHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbl9fbmFtZShjb25maWcsIFwiY29uZmlnXCIpO1xuX19uYW1lMihjb25maWcsIFwiY29uZmlnXCIpO1xuZnVuY3Rpb24gY29zKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xufVxuX19uYW1lKGNvcywgXCJjb3NcIik7XG5fX25hbWUyKGNvcywgXCJjb3NcIik7XG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcbn1cbl9fbmFtZShjb3NoLCBcImNvc2hcIik7XG5fX25hbWUyKGNvc2gsIFwiY29zaFwiKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICB2YXIgaSwgcCwgcHM7XG4gIGZ1bmN0aW9uIERlY2ltYWwyKHYpIHtcbiAgICB2YXIgZSwgaTIsIHQsIHggPSB0aGlzO1xuICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsMikpXG4gICAgICByZXR1cm4gbmV3IERlY2ltYWwyKHYpO1xuICAgIHguY29uc3RydWN0b3IgPSBEZWNpbWFsMjtcbiAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcbiAgICAgIHgucyA9IHYucztcbiAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICBpZiAoIXYuZCB8fCB2LmUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgRGVjaW1hbDIubWluRSkge1xuICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IHYuZTtcbiAgICAgICAgICB4LmQgPSB2LmQuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICB4LmQgPSB2LmQgPyB2LmQuc2xpY2UoKSA6IHYuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCA9IHR5cGVvZiB2O1xuICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHguZSA9IDA7XG4gICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgeC5zID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LnMgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XG4gICAgICAgIGZvciAoZSA9IDAsIGkyID0gdjsgaTIgPj0gMTA7IGkyIC89IDEwKVxuICAgICAgICAgIGUrKztcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgaWYgKGUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgICB4LmUgPSBOYU47XG4gICAgICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZSA8IERlY2ltYWwyLm1pbkUpIHtcbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmQgPSBbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgICB4LmQgPSBbdl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IGU7XG4gICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodiAqIDAgIT09IDApIHtcbiAgICAgICAgaWYgKCF2KVxuICAgICAgICAgIHgucyA9IE5hTjtcbiAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICB4LmQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB2KTtcbiAgICB9XG4gICAgaWYgKChpMiA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7XG4gICAgICB2ID0gdi5zbGljZSgxKTtcbiAgICAgIHgucyA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaTIgPT09IDQzKVxuICAgICAgICB2ID0gdi5zbGljZSgxKTtcbiAgICAgIHgucyA9IDE7XG4gICAgfVxuICAgIHJldHVybiBpc0RlY2ltYWwudGVzdCh2KSA/IHBhcnNlRGVjaW1hbCh4LCB2KSA6IHBhcnNlT3RoZXIoeCwgdik7XG4gIH1cbiAgX19uYW1lKERlY2ltYWwyLCBcIkRlY2ltYWwyXCIpO1xuICBfX25hbWUyKERlY2ltYWwyLCBcIkRlY2ltYWxcIik7XG4gIERlY2ltYWwyLnByb3RvdHlwZSA9IFA7XG4gIERlY2ltYWwyLlJPVU5EX1VQID0gMDtcbiAgRGVjaW1hbDIuUk9VTkRfRE9XTiA9IDE7XG4gIERlY2ltYWwyLlJPVU5EX0NFSUwgPSAyO1xuICBEZWNpbWFsMi5ST1VORF9GTE9PUiA9IDM7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfVVAgPSA0O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0RPV04gPSA1O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0VWRU4gPSA2O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0NFSUwgPSA3O1xuICBEZWNpbWFsMi5ST1VORF9IQUxGX0ZMT09SID0gODtcbiAgRGVjaW1hbDIuRVVDTElEID0gOTtcbiAgRGVjaW1hbDIuY29uZmlnID0gRGVjaW1hbDIuc2V0ID0gY29uZmlnO1xuICBEZWNpbWFsMi5jbG9uZSA9IGNsb25lO1xuICBEZWNpbWFsMi5pc0RlY2ltYWwgPSBpc0RlY2ltYWxJbnN0YW5jZTtcbiAgRGVjaW1hbDIuYWJzID0gYWJzO1xuICBEZWNpbWFsMi5hY29zID0gYWNvcztcbiAgRGVjaW1hbDIuYWNvc2ggPSBhY29zaDtcbiAgRGVjaW1hbDIuYWRkID0gYWRkO1xuICBEZWNpbWFsMi5hc2luID0gYXNpbjtcbiAgRGVjaW1hbDIuYXNpbmggPSBhc2luaDtcbiAgRGVjaW1hbDIuYXRhbiA9IGF0YW47XG4gIERlY2ltYWwyLmF0YW5oID0gYXRhbmg7XG4gIERlY2ltYWwyLmF0YW4yID0gYXRhbjI7XG4gIERlY2ltYWwyLmNicnQgPSBjYnJ0O1xuICBEZWNpbWFsMi5jZWlsID0gY2VpbDtcbiAgRGVjaW1hbDIuY2xhbXAgPSBjbGFtcDtcbiAgRGVjaW1hbDIuY29zID0gY29zO1xuICBEZWNpbWFsMi5jb3NoID0gY29zaDtcbiAgRGVjaW1hbDIuZGl2ID0gZGl2O1xuICBEZWNpbWFsMi5leHAgPSBleHA7XG4gIERlY2ltYWwyLmZsb29yID0gZmxvb3I7XG4gIERlY2ltYWwyLmh5cG90ID0gaHlwb3Q7XG4gIERlY2ltYWwyLmxuID0gbG47XG4gIERlY2ltYWwyLmxvZyA9IGxvZztcbiAgRGVjaW1hbDIubG9nMTAgPSBsb2cxMDtcbiAgRGVjaW1hbDIubG9nMiA9IGxvZzI7XG4gIERlY2ltYWwyLm1heCA9IG1heDtcbiAgRGVjaW1hbDIubWluID0gbWluO1xuICBEZWNpbWFsMi5tb2QgPSBtb2Q7XG4gIERlY2ltYWwyLm11bCA9IG11bDtcbiAgRGVjaW1hbDIucG93ID0gcG93O1xuICBEZWNpbWFsMi5yYW5kb20gPSByYW5kb207XG4gIERlY2ltYWwyLnJvdW5kID0gcm91bmQ7XG4gIERlY2ltYWwyLnNpZ24gPSBzaWduO1xuICBEZWNpbWFsMi5zaW4gPSBzaW47XG4gIERlY2ltYWwyLnNpbmggPSBzaW5oO1xuICBEZWNpbWFsMi5zcXJ0ID0gc3FydDtcbiAgRGVjaW1hbDIuc3ViID0gc3ViO1xuICBEZWNpbWFsMi5zdW0gPSBzdW07XG4gIERlY2ltYWwyLnRhbiA9IHRhbjtcbiAgRGVjaW1hbDIudGFuaCA9IHRhbmg7XG4gIERlY2ltYWwyLnRydW5jID0gdHJ1bmM7XG4gIGlmIChvYmogPT09IHZvaWQgMClcbiAgICBvYmogPSB7fTtcbiAgaWYgKG9iaikge1xuICAgIGlmIChvYmouZGVmYXVsdHMgIT09IHRydWUpIHtcbiAgICAgIHBzID0gW1wicHJlY2lzaW9uXCIsIFwicm91bmRpbmdcIiwgXCJ0b0V4cE5lZ1wiLCBcInRvRXhwUG9zXCIsIFwibWF4RVwiLCBcIm1pbkVcIiwgXCJtb2R1bG9cIiwgXCJjcnlwdG9cIl07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyApXG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KHAgPSBwc1tpKytdKSlcbiAgICAgICAgICBvYmpbcF0gPSB0aGlzW3BdO1xuICAgIH1cbiAgfVxuICBEZWNpbWFsMi5jb25maWcob2JqKTtcbiAgcmV0dXJuIERlY2ltYWwyO1xufVxuX19uYW1lKGNsb25lLCBcImNsb25lXCIpO1xuX19uYW1lMihjbG9uZSwgXCJjbG9uZVwiKTtcbmZ1bmN0aW9uIGRpdih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5kaXYoeSk7XG59XG5fX25hbWUoZGl2LCBcImRpdlwiKTtcbl9fbmFtZTIoZGl2LCBcImRpdlwiKTtcbmZ1bmN0aW9uIGV4cCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcbn1cbl9fbmFtZShleHAsIFwiZXhwXCIpO1xuX19uYW1lMihleHAsIFwiZXhwXCIpO1xuZnVuY3Rpb24gZmxvb3IoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAzKTtcbn1cbl9fbmFtZShmbG9vciwgXCJmbG9vclwiKTtcbl9fbmFtZTIoZmxvb3IsIFwiZmxvb3JcIik7XG5mdW5jdGlvbiBoeXBvdCgpIHtcbiAgdmFyIGksIG4sIHQgPSBuZXcgdGhpcygwKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICkge1xuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XG4gICAgaWYgKCFuLmQpIHtcbiAgICAgIGlmIChuLnMpIHtcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoMSAvIDApO1xuICAgICAgfVxuICAgICAgdCA9IG47XG4gICAgfSBlbHNlIGlmICh0LmQpIHtcbiAgICAgIHQgPSB0LnBsdXMobi50aW1lcyhuKSk7XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHQuc3FydCgpO1xufVxuX19uYW1lKGh5cG90LCBcImh5cG90XCIpO1xuX19uYW1lMihoeXBvdCwgXCJoeXBvdFwiKTtcbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGVjaW1hbCB8fCBvYmogJiYgb2JqLnRvU3RyaW5nVGFnID09PSB0YWcgfHwgZmFsc2U7XG59XG5fX25hbWUoaXNEZWNpbWFsSW5zdGFuY2UsIFwiaXNEZWNpbWFsSW5zdGFuY2VcIik7XG5fX25hbWUyKGlzRGVjaW1hbEluc3RhbmNlLCBcImlzRGVjaW1hbEluc3RhbmNlXCIpO1xuZnVuY3Rpb24gbG4oeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG4oKTtcbn1cbl9fbmFtZShsbiwgXCJsblwiKTtcbl9fbmFtZTIobG4sIFwibG5cIik7XG5mdW5jdGlvbiBsb2coeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKHkpO1xufVxuX19uYW1lKGxvZywgXCJsb2dcIik7XG5fX25hbWUyKGxvZywgXCJsb2dcIik7XG5mdW5jdGlvbiBsb2cyKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcbn1cbl9fbmFtZShsb2cyLCBcImxvZzJcIik7XG5fX25hbWUyKGxvZzIsIFwibG9nMlwiKTtcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygxMCk7XG59XG5fX25hbWUobG9nMTAsIFwibG9nMTBcIik7XG5fX25hbWUyKGxvZzEwLCBcImxvZzEwXCIpO1xuZnVuY3Rpb24gbWF4KCkge1xuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCBcImx0XCIpO1xufVxuX19uYW1lKG1heCwgXCJtYXhcIik7XG5fX25hbWUyKG1heCwgXCJtYXhcIik7XG5mdW5jdGlvbiBtaW4oKSB7XG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIFwiZ3RcIik7XG59XG5fX25hbWUobWluLCBcIm1pblwiKTtcbl9fbmFtZTIobWluLCBcIm1pblwiKTtcbmZ1bmN0aW9uIG1vZCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tb2QoeSk7XG59XG5fX25hbWUobW9kLCBcIm1vZFwiKTtcbl9fbmFtZTIobW9kLCBcIm1vZFwiKTtcbmZ1bmN0aW9uIG11bCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tdWwoeSk7XG59XG5fX25hbWUobXVsLCBcIm11bFwiKTtcbl9fbmFtZTIobXVsLCBcIm11bFwiKTtcbmZ1bmN0aW9uIHBvdyh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5wb3coeSk7XG59XG5fX25hbWUocG93LCBcInBvd1wiKTtcbl9fbmFtZTIocG93LCBcInBvd1wiKTtcbmZ1bmN0aW9uIHJhbmRvbShzZCkge1xuICB2YXIgZCwgZSwgaywgbiwgaSA9IDAsIHIgPSBuZXcgdGhpcygxKSwgcmQgPSBbXTtcbiAgaWYgKHNkID09PSB2b2lkIDApXG4gICAgc2QgPSB0aGlzLnByZWNpc2lvbjtcbiAgZWxzZVxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICBrID0gTWF0aC5jZWlsKHNkIC8gTE9HX0JBU0UpO1xuICBpZiAoIXRoaXMuY3J5cHRvKSB7XG4gICAgZm9yICg7IGkgPCBrOyApXG4gICAgICByZFtpKytdID0gTWF0aC5yYW5kb20oKSAqIDFlNyB8IDA7XG4gIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGQgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrKSk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldO1xuICAgICAgaWYgKG4gPj0gNDI5ZTcpIHtcbiAgICAgICAgZFtpXSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkW2krK10gPSBuICUgMWU3O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICBkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNCk7XG4gICAgZm9yICg7IGkgPCBrOyApIHtcbiAgICAgIG4gPSBkW2ldICsgKGRbaSArIDFdIDw8IDgpICsgKGRbaSArIDJdIDw8IDE2KSArICgoZFtpICsgM10gJiAxMjcpIDw8IDI0KTtcbiAgICAgIGlmIChuID49IDIxNGU3KSB7XG4gICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGQsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmQucHVzaChuICUgMWU3KTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICBpID0gayAvIDQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xuICB9XG4gIGsgPSByZFstLWldO1xuICBzZCAlPSBMT0dfQkFTRTtcbiAgaWYgKGsgJiYgc2QpIHtcbiAgICBuID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBzZCk7XG4gICAgcmRbaV0gPSAoayAvIG4gfCAwKSAqIG47XG4gIH1cbiAgZm9yICg7IHJkW2ldID09PSAwOyBpLS0pXG4gICAgcmQucG9wKCk7XG4gIGlmIChpIDwgMCkge1xuICAgIGUgPSAwO1xuICAgIHJkID0gWzBdO1xuICB9IGVsc2Uge1xuICAgIGUgPSAtMTtcbiAgICBmb3IgKDsgcmRbMF0gPT09IDA7IGUgLT0gTE9HX0JBU0UpXG4gICAgICByZC5zaGlmdCgpO1xuICAgIGZvciAoayA9IDEsIG4gPSByZFswXTsgbiA+PSAxMDsgbiAvPSAxMClcbiAgICAgIGsrKztcbiAgICBpZiAoayA8IExPR19CQVNFKVxuICAgICAgZSAtPSBMT0dfQkFTRSAtIGs7XG4gIH1cbiAgci5lID0gZTtcbiAgci5kID0gcmQ7XG4gIHJldHVybiByO1xufVxuX19uYW1lKHJhbmRvbSwgXCJyYW5kb21cIik7XG5fX25hbWUyKHJhbmRvbSwgXCJyYW5kb21cIik7XG5mdW5jdGlvbiByb3VuZCh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xufVxuX19uYW1lKHJvdW5kLCBcInJvdW5kXCIpO1xuX19uYW1lMihyb3VuZCwgXCJyb3VuZFwiKTtcbmZ1bmN0aW9uIHNpZ24oeCkge1xuICB4ID0gbmV3IHRoaXMoeCk7XG4gIHJldHVybiB4LmQgPyB4LmRbMF0gPyB4LnMgOiAwICogeC5zIDogeC5zIHx8IE5hTjtcbn1cbl9fbmFtZShzaWduLCBcInNpZ25cIik7XG5fX25hbWUyKHNpZ24sIFwic2lnblwiKTtcbmZ1bmN0aW9uIHNpbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW4oKTtcbn1cbl9fbmFtZShzaW4sIFwic2luXCIpO1xuX19uYW1lMihzaW4sIFwic2luXCIpO1xuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XG59XG5fX25hbWUoc2luaCwgXCJzaW5oXCIpO1xuX19uYW1lMihzaW5oLCBcInNpbmhcIik7XG5mdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcbn1cbl9fbmFtZShzcXJ0LCBcInNxcnRcIik7XG5fX25hbWUyKHNxcnQsIFwic3FydFwiKTtcbmZ1bmN0aW9uIHN1Yih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XG59XG5fX25hbWUoc3ViLCBcInN1YlwiKTtcbl9fbmFtZTIoc3ViLCBcInN1YlwiKTtcbmZ1bmN0aW9uIHN1bSgpIHtcbiAgdmFyIGkgPSAwLCBhcmdzID0gYXJndW1lbnRzLCB4ID0gbmV3IHRoaXMoYXJnc1tpXSk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoOyB4LnMgJiYgKytpIDwgYXJncy5sZW5ndGg7IClcbiAgICB4ID0geC5wbHVzKGFyZ3NbaV0pO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiBmaW5hbGlzZSh4LCB0aGlzLnByZWNpc2lvbiwgdGhpcy5yb3VuZGluZyk7XG59XG5fX25hbWUoc3VtLCBcInN1bVwiKTtcbl9fbmFtZTIoc3VtLCBcInN1bVwiKTtcbmZ1bmN0aW9uIHRhbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcbn1cbl9fbmFtZSh0YW4sIFwidGFuXCIpO1xuX19uYW1lMih0YW4sIFwidGFuXCIpO1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW5oKCk7XG59XG5fX25hbWUodGFuaCwgXCJ0YW5oXCIpO1xuX19uYW1lMih0YW5oLCBcInRhbmhcIik7XG5mdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xufVxuX19uYW1lKHRydW5jLCBcInRydW5jXCIpO1xuX19uYW1lMih0cnVuYywgXCJ0cnVuY1wiKTtcblBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSA9IFAudG9TdHJpbmc7XG5QW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIkRlY2ltYWxcIjtcbnZhciBEZWNpbWFsID0gUC5jb25zdHJ1Y3RvciA9IGNsb25lKERFRkFVTFRTKTtcbkxOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcblBJID0gbmV3IERlY2ltYWwoUEkpO1xudmFyIGRlY2ltYWxfZGVmYXVsdCA9IERlY2ltYWw7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRGVjaW1hbFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@prisma/client/runtime/index-browser.js\n");

/***/ }),

/***/ "./src/helpers/movies.ts":
/*!*******************************!*\
  !*** ./src/helpers/movies.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cleanMovie\": function() { return /* binding */ cleanMovie; },\n/* harmony export */   \"cleanMovies\": function() { return /* binding */ cleanMovies; },\n/* harmony export */   \"cleanActors\": function() { return /* binding */ cleanActors; },\n/* harmony export */   \"getStars\": function() { return /* binding */ getStars; },\n/* harmony export */   \"getGenresIDs\": function() { return /* binding */ getGenresIDs; }\n/* harmony export */ });\n/* harmony import */ var _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/regenerator-runtime/runtime.js */ \"./node_modules/next/dist/compiled/regenerator-runtime/runtime.js\");\n/* harmony import */ var _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ \"./node_modules/lodash-es/omit.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ \"./node_modules/lodash-es/isInteger.js\");\n/* harmony import */ var _constants_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/images */ \"./src/constants/images.ts\");\n/* harmony import */ var _src_helpers_prisma__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/src/helpers/prisma */ \"./src/helpers/prisma.ts\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _asyncToGenerator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar getGenres = function() {\n    var _ref = _asyncToGenerator(_Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {\n        var TMDB_KEY, ref, genres;\n        return _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    TMDB_KEY = process.env.TMDB_KEY;\n                    _ctx.next = 3;\n                    return axios__WEBPACK_IMPORTED_MODULE_1___default().get(\"https://api.themoviedb.org/3/genre/movie/list?api_key=\".concat(TMDB_KEY, \"&language=en-US\"));\n                case 3:\n                    ref = _ctx.sent;\n                    genres = ref.data.genres;\n                    return _ctx.abrupt(\"return\", genres);\n                case 6:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return function getGenres() {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar appendGenres = function() {\n    var _ref = _asyncToGenerator(_Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(movies) {\n        var genres;\n        return _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    _ctx.next = 2;\n                    return getGenres();\n                case 2:\n                    genres = _ctx.sent;\n                    return _ctx.abrupt(\"return\", movies.map(function(movie) {\n                        return _objectSpread({}, movie, {\n                            genres: movie.genre_ids.map(function(id) {\n                                return {\n                                    id: id,\n                                    name: genres.find(function(g) {\n                                        return g.id === id;\n                                    }).name\n                                };\n                            })\n                        });\n                    }).map(function(m) {\n                        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(m, \"genre_ids\");\n                    }));\n                case 4:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return function appendGenres(movies) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar appendImageUrl = function(movies) {\n    return movies.map(function(movie) {\n        return _objectSpread({}, (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(movie, [\n            \"poster_path\",\n            \"backdrop_path\"\n        ]), {\n            posters: _constants_images__WEBPACK_IMPORTED_MODULE_2__.IMAGES.poster_sizes.map(function(size) {\n                return _defineProperty({}, size, movie.poster_path ? _constants_images__WEBPACK_IMPORTED_MODULE_2__.IMAGES.secure_base_url + size + movie.poster_path : null);\n            }).reduce(function(acc, curr) {\n                return _objectSpread({}, acc, curr);\n            }, {}),\n            backdrops: _constants_images__WEBPACK_IMPORTED_MODULE_2__.IMAGES.backdrop_sizes.map(function(size) {\n                return _defineProperty({}, size, movie.backdrop_path ? _constants_images__WEBPACK_IMPORTED_MODULE_2__.IMAGES.secure_base_url + size + movie.backdrop_path : null);\n            }).reduce(function(acc, curr) {\n                return _objectSpread({}, acc, curr);\n            }, {})\n        });\n    });\n};\nvar cleanMovie = function(movie) {\n    var ref = _slicedToArray(appendImageUrl([\n        movie\n    ]), 1), withImageUrl = ref[0];\n    return withImageUrl;\n};\nvar cleanMovies = function() {\n    var _ref = _asyncToGenerator(_Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(movies) {\n        var withImageUrl, withGenres;\n        return _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    withImageUrl = appendImageUrl(movies.results);\n                    _ctx.next = 3;\n                    return appendGenres(withImageUrl);\n                case 3:\n                    withGenres = _ctx.sent;\n                    return _ctx.abrupt(\"return\", _objectSpread({}, movies, {\n                        results: withGenres\n                    }));\n                case 5:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return function cleanMovies(movies) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar cleanActors = function(cast) {\n    return cast.map(function(actor) {\n        return _objectSpread({}, actor, {\n            profile_path: _constants_images__WEBPACK_IMPORTED_MODULE_2__.IMAGES.secure_base_url + \"w185\" + actor.profile_path\n        });\n    });\n};\nvar getStars = function(a) {\n    if (!a) return {};\n    var divided = Math.round(a / 2 * 2) / 2;\n    var value = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(divided) ? divided : divided - 0.5;\n    return {\n        withHalf: (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(divided),\n        value: value,\n        starsFull: Array.from(Array(value).keys()),\n        starsEmpty: Array.from(Array(5 - value).keys())\n    };\n};\nvar getGenresIDs = function() {\n    var _ref = _asyncToGenerator(_Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee(movie) {\n        var existingGenres, existingGenresIDs;\n        return _Users_saravieira_Projects_moviemash_node_modules_next_dist_compiled_regenerator_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_ctx) {\n            while(1)switch(_ctx.prev = _ctx.next){\n                case 0:\n                    _ctx.next = 2;\n                    return _src_helpers_prisma__WEBPACK_IMPORTED_MODULE_3__[\"default\"].genre.findMany({\n                        where: {\n                            id: {\n                                in: movie.genres.map(function(m) {\n                                    return m.id;\n                                })\n                            }\n                        },\n                        select: {\n                            id: true\n                        }\n                    });\n                case 2:\n                    existingGenres = _ctx.sent;\n                    existingGenresIDs = existingGenres.map(function(g) {\n                        return g.id;\n                    });\n                    return _ctx.abrupt(\"return\", existingGenresIDs);\n                case 5:\n                case \"end\":\n                    return _ctx.stop();\n            }\n        }, _callee);\n    }));\n    return function getGenresIDs(movie) {\n        return _ref.apply(this, arguments);\n    };\n}();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUssSUFBSTtRQUN2Q0MsVUFBVSxFQUFFSCxLQUFLLENBQUNDLElBQUksQ0FBQ0QsS0FBSyxDQUFDLENBQUMsR0FBR0gsS0FBSyxFQUFFSyxJQUFJO0lBQzlDLENBQUM7QUFDSCxDQUFDO0FBRU0sR0FBSyxDQUFDRSxZQUFZO2lMQUFHLFFBQVEsU0FBRHhDLEtBQUssRUFBSyxDQUFDO1lBQ3RDeUMsY0FBYyxFQVVkQyxpQkFBaUI7Ozs7OzJCQVZNckQsMEVBQXFCLENBQUMsQ0FBQzt3QkFDbER3RCxLQUFLLEVBQUUsQ0FBQzs0QkFDTjNDLEVBQUUsRUFBRSxDQUFDO2dDQUNINEMsRUFBRSxFQUFFOUMsS0FBSyxDQUFDUixNQUFNLENBQUNPLEdBQUcsQ0FBQyxRQUFRLENBQVBPLENBQUM7b0NBQUtBLE1BQU0sQ0FBTkEsQ0FBQyxDQUFDSixFQUFFOzs0QkFDbEMsQ0FBQzt3QkFDSCxDQUFDO3dCQUNENkMsTUFBTSxFQUFFLENBQUM7NEJBQ1A3QyxFQUFFLEVBQUUsSUFBSTt3QkFDVixDQUFDO29CQUNILENBQUM7O29CQVRLdUMsY0FBYztvQkFVZEMsaUJBQWlCLEdBQUdELGNBQWMsQ0FBQzFDLEdBQUcsQ0FBQyxRQUFRLENBQVBNLENBQUM7d0JBQUtBLE1BQU0sQ0FBTkEsQ0FBQyxDQUFDSCxFQUFFOztpREFFakR3QyxpQkFBaUI7Ozs7OztJQUMxQixDQUFDO29CQWRZRixZQUFZLENBQVV4QyxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL21vdmllcy50cz83ZDAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IGlzSW50ZWdlciwgb21pdCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IElNQUdFUyB9IGZyb20gXCIuLi9jb25zdGFudHMvaW1hZ2VzXCI7XG5pbXBvcnQgcHJpc21hIGZyb20gXCJAL3NyYy9oZWxwZXJzL3ByaXNtYVwiO1xuY29uc3QgZ2V0R2VucmVzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IFRNREJfS0VZIH0gPSBwcm9jZXNzLmVudjtcbiAgY29uc3Qge1xuICAgIGRhdGE6IHsgZ2VucmVzIH0sXG4gIH0gPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgYGh0dHBzOi8vYXBpLnRoZW1vdmllZGIub3JnLzMvZ2VucmUvbW92aWUvbGlzdD9hcGlfa2V5PSR7VE1EQl9LRVl9Jmxhbmd1YWdlPWVuLVVTYFxuICApO1xuXG4gIHJldHVybiBnZW5yZXM7XG59O1xuXG5jb25zdCBhcHBlbmRHZW5yZXMgPSBhc3luYyAobW92aWVzKSA9PiB7XG4gIGNvbnN0IGdlbnJlcyA9IGF3YWl0IGdldEdlbnJlcygpO1xuXG4gIHJldHVybiBtb3ZpZXNcbiAgICAubWFwKChtb3ZpZSkgPT4gKHtcbiAgICAgIC4uLm1vdmllLFxuICAgICAgZ2VucmVzOiBtb3ZpZS5nZW5yZV9pZHMubWFwKChpZCkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWU6IGdlbnJlcy5maW5kKChnKSA9PiBnLmlkID09PSBpZCkubmFtZSxcbiAgICAgIH0pKSxcbiAgICB9KSlcbiAgICAubWFwKChtKSA9PiBvbWl0KG0sIFwiZ2VucmVfaWRzXCIpKTtcbn07XG5cbmNvbnN0IGFwcGVuZEltYWdlVXJsID0gKG1vdmllcykgPT5cbiAgbW92aWVzLm1hcCgobW92aWUpID0+ICh7XG4gICAgLi4ub21pdChtb3ZpZSwgW1wicG9zdGVyX3BhdGhcIiwgXCJiYWNrZHJvcF9wYXRoXCJdKSxcbiAgICBwb3N0ZXJzOiBJTUFHRVMucG9zdGVyX3NpemVzXG4gICAgICAubWFwKChzaXplKSA9PiAoe1xuICAgICAgICBbc2l6ZV06IG1vdmllLnBvc3Rlcl9wYXRoXG4gICAgICAgICAgPyBJTUFHRVMuc2VjdXJlX2Jhc2VfdXJsICsgc2l6ZSArIG1vdmllLnBvc3Rlcl9wYXRoXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgfSkpXG4gICAgICAucmVkdWNlKChhY2MsIGN1cnIpID0+ICh7IC4uLmFjYywgLi4uY3VyciB9KSwge30pLFxuICAgIGJhY2tkcm9wczogSU1BR0VTLmJhY2tkcm9wX3NpemVzXG4gICAgICAubWFwKChzaXplKSA9PiAoe1xuICAgICAgICBbc2l6ZV06IG1vdmllLmJhY2tkcm9wX3BhdGhcbiAgICAgICAgICA/IElNQUdFUy5zZWN1cmVfYmFzZV91cmwgKyBzaXplICsgbW92aWUuYmFja2Ryb3BfcGF0aFxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIH0pKVxuICAgICAgLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiAoeyAuLi5hY2MsIC4uLmN1cnIgfSksIHt9KSxcbiAgfSkpO1xuXG5leHBvcnQgY29uc3QgY2xlYW5Nb3ZpZSA9IChtb3ZpZSkgPT4ge1xuICBjb25zdCBbd2l0aEltYWdlVXJsXSA9IGFwcGVuZEltYWdlVXJsKFttb3ZpZV0pO1xuXG4gIHJldHVybiB3aXRoSW1hZ2VVcmw7XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYW5Nb3ZpZXMgPSBhc3luYyAobW92aWVzKSA9PiB7XG4gIGNvbnN0IHdpdGhJbWFnZVVybCA9IGFwcGVuZEltYWdlVXJsKG1vdmllcy5yZXN1bHRzKTtcbiAgY29uc3Qgd2l0aEdlbnJlcyA9IGF3YWl0IGFwcGVuZEdlbnJlcyh3aXRoSW1hZ2VVcmwpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ubW92aWVzLFxuICAgIHJlc3VsdHM6IHdpdGhHZW5yZXMsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY2xlYW5BY3RvcnMgPSAoY2FzdCkgPT5cbiAgY2FzdC5tYXAoKGFjdG9yKSA9PiAoe1xuICAgIC4uLmFjdG9yLFxuICAgIHByb2ZpbGVfcGF0aDogSU1BR0VTLnNlY3VyZV9iYXNlX3VybCArIFwidzE4NVwiICsgYWN0b3IucHJvZmlsZV9wYXRoLFxuICB9KSk7XG5cbmV4cG9ydCBjb25zdCBnZXRTdGFycyA9IChhKSA9PiB7XG4gIGlmICghYSkgcmV0dXJuIHt9O1xuICBjb25zdCBkaXZpZGVkID0gTWF0aC5yb3VuZCgoYSAvIDIpICogMikgLyAyO1xuICBjb25zdCB2YWx1ZSA9IGlzSW50ZWdlcihkaXZpZGVkKSA/IGRpdmlkZWQgOiBkaXZpZGVkIC0gMC41O1xuXG4gIHJldHVybiB7XG4gICAgd2l0aEhhbGY6IGlzSW50ZWdlcihkaXZpZGVkKSxcbiAgICB2YWx1ZSxcbiAgICBzdGFyc0Z1bGw6IEFycmF5LmZyb20oQXJyYXkodmFsdWUpLmtleXMoKSksXG4gICAgc3RhcnNFbXB0eTogQXJyYXkuZnJvbShBcnJheSg1IC0gdmFsdWUpLmtleXMoKSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0R2VucmVzSURzID0gYXN5bmMgKG1vdmllKSA9PiB7XG4gIGNvbnN0IGV4aXN0aW5nR2VucmVzID0gYXdhaXQgcHJpc21hLmdlbnJlLmZpbmRNYW55KHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHtcbiAgICAgICAgaW46IG1vdmllLmdlbnJlcy5tYXAoKG0pID0+IG0uaWQpLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgaWQ6IHRydWUsXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IGV4aXN0aW5nR2VucmVzSURzID0gZXhpc3RpbmdHZW5yZXMubWFwKChnKSA9PiBnLmlkKTtcblxuICByZXR1cm4gZXhpc3RpbmdHZW5yZXNJRHM7XG59O1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiaXNJbnRlZ2VyIiwib21pdCIsIklNQUdFUyIsInByaXNtYSIsImdldEdlbnJlcyIsIlRNREJfS0VZIiwiZ2VucmVzIiwicHJvY2VzcyIsImVudiIsImdldCIsImRhdGEiLCJhcHBlbmRHZW5yZXMiLCJtb3ZpZXMiLCJtYXAiLCJtb3ZpZSIsImdlbnJlX2lkcyIsImlkIiwibmFtZSIsImZpbmQiLCJnIiwibSIsImFwcGVuZEltYWdlVXJsIiwicG9zdGVycyIsInBvc3Rlcl9zaXplcyIsInNpemUiLCJwb3N0ZXJfcGF0aCIsInNlY3VyZV9iYXNlX3VybCIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJiYWNrZHJvcHMiLCJiYWNrZHJvcF9zaXplcyIsImJhY2tkcm9wX3BhdGgiLCJjbGVhbk1vdmllIiwid2l0aEltYWdlVXJsIiwiY2xlYW5Nb3ZpZXMiLCJ3aXRoR2VucmVzIiwicmVzdWx0cyIsImNsZWFuQWN0b3JzIiwiY2FzdCIsImFjdG9yIiwicHJvZmlsZV9wYXRoIiwiZ2V0U3RhcnMiLCJhIiwiZGl2aWRlZCIsIk1hdGgiLCJyb3VuZCIsInZhbHVlIiwid2l0aEhhbGYiLCJzdGFyc0Z1bGwiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic3RhcnNFbXB0eSIsImdldEdlbnJlc0lEcyIsImV4aXN0aW5nR2VucmVzIiwiZXhpc3RpbmdHZW5yZXNJRHMiLCJnZW5yZSIsImZpbmRNYW55Iiwid2hlcmUiLCJpbiIsInNlbGVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/helpers/movies.ts\n");

/***/ }),

/***/ "./src/helpers/prisma.ts":
/*!*******************************!*\
  !*** ./src/helpers/prisma.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"./node_modules/@prisma/client/index-browser.js\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\nvar prisma = __webpack_require__.g.prisma || new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log: [\n        \"query\"\n    ]\n});\nif (true) __webpack_require__.g.prisma = prisma;\n/* harmony default export */ __webpack_exports__[\"default\"] = (prisma);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            var currentExports = module.__proto__.exports;\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy9wcmlzbWEudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUE2QztBQVM3QyxHQUFLLENBQUNDLE1BQU0sR0FDVkMscUJBQU0sQ0FBQ0QsTUFBTSxJQUNiLEdBQUcsQ0FBQ0Qsd0RBQVksQ0FBQyxDQUFDO0lBQ2hCRyxHQUFHLEVBQUUsQ0FBQztRQUFBLENBQU87SUFBQSxDQUFDO0FBQ2hCLENBQUM7QUFFSCxFQUFFLEVBZkYsSUFleUMsRUFBRUQscUJBQU0sQ0FBQ0QsTUFBTSxHQUFHQSxNQUFNO0FBRWpFLCtEQUFlQSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hlbHBlcnMvcHJpc21hLnRzPzdmNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gYWxsb3cgZ2xvYmFsIGB2YXJgIGRlY2xhcmF0aW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgcHJpc21hOiBQcmlzbWFDbGllbnQgfCB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHByaXNtYSA9XG4gIGdsb2JhbC5wcmlzbWEgfHxcbiAgbmV3IFByaXNtYUNsaWVudCh7XG4gICAgbG9nOiBbXCJxdWVyeVwiXSxcbiAgfSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIGdsb2JhbC5wcmlzbWEgPSBwcmlzbWE7XG5cbmV4cG9ydCBkZWZhdWx0IHByaXNtYTtcbiJdLCJuYW1lcyI6WyJQcmlzbWFDbGllbnQiLCJwcmlzbWEiLCJnbG9iYWwiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/helpers/prisma.ts\n");

/***/ })

});